import{_ as e,c as n,b as t,o as i}from"./app-CeNqR5SR.js";const l="/clarence-doc/assets/how_jvm_run-DCNsWcEY.png",r={};function s(o,a){return i(),n("div",null,a[0]||(a[0]=[t('<h1 id="java总结-jvm" tabindex="-1"><a class="header-anchor" href="#java总结-jvm"><span>Java总结-JVM</span></a></h1><h2 id="jvm是如何运行的" tabindex="-1"><a class="header-anchor" href="#jvm是如何运行的"><span>JVM是如何运行的？</span></a></h2><p>VM（Java Virtual Machine，Java虚拟机）是 Java 程序的运行环境，它负责将 Java 字节码翻译成机器代码并执行。也就是说 Java 代码之所以能够运行，主要是依靠 JVM 来实现的。</p><p>JVM 整体的大概执行流程是这样的：</p><ol><li>程序在执行之前先要把 Java 代码转换成字节码（class 文件），JVM 首先需要把字节码通过一定的方式<strong>类加载器（ClassLoader）</strong> 把文件加载到内存中<strong>运行时数据区（Runtime Data Area）</strong>；</li><li>但字节码文件是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器，也就是 JVM 的执行引擎（Execution Engine）会<strong>将字节码翻译成底层系统指令再交由 CPU 去执行</strong>；</li><li>在执行的过程中，也需要调用其他语言的接口，如通过<strong>调用本地库接口（Native Interface）</strong> 来实现整个程序的运行，如下图所示： <img src="'+l+'" alt="img.png"></li></ol><p>所以，整体来看， JVM 主要通过分为以下 4 个部分，来执行 Java 程序的，它们分别是：</p><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><h2 id="说说jvm的内存模型" tabindex="-1"><a class="header-anchor" href="#说说jvm的内存模型"><span>说说JVM的内存模型？</span></a></h2>',8)]))}const m=e(r,[["render",s],["__file","4_jvm.html.vue"]]),v=JSON.parse('{"path":"/interview/4_jvm.html","title":"Java总结-JVM","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"JVM是如何运行的？","slug":"jvm是如何运行的","link":"#jvm是如何运行的","children":[]},{"level":2,"title":"说说JVM的内存模型？","slug":"说说jvm的内存模型","link":"#说说jvm的内存模型","children":[]}],"git":{"updatedTime":1738922529000,"contributors":[{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":2,"url":"https://github.com/hanchen"}]},"filePathRelative":"interview/4_jvm.md"}');export{m as comp,v as data};
