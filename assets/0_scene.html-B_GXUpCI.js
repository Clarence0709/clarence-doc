import{_ as l,c as s,a,b as i,d as n,e as t,f as h,r as o,o as c}from"./app-CQZD7F5p.js";const d={};function p(u,e){const r=o("RouteLink");return c(),s("div",null,[e[2]||(e[2]=a('<h1 id="常见的场景问题" tabindex="-1"><a class="header-anchor" href="#常见的场景问题"><span>常见的场景问题</span></a></h1><h2 id="一、分布式系统主键如何处理" tabindex="-1"><a class="header-anchor" href="#一、分布式系统主键如何处理"><span>一、分布式系统主键如何处理？</span></a></h2><h3 id="_1、节点生成-or-主键服务" tabindex="-1"><a class="header-anchor" href="#_1、节点生成-or-主键服务"><span>1、节点生成 or 主键服务？</span></a></h3><h3 id="_2、主键类型的选择" tabindex="-1"><a class="header-anchor" href="#_2、主键类型的选择"><span>2、主键类型的选择？</span></a></h3><h2 id="二、针对于过期的订单-如何处理" tabindex="-1"><a class="header-anchor" href="#二、针对于过期的订单-如何处理"><span>二、针对于过期的订单，如何处理？</span></a></h2><p><a href="https://mp.weixin.qq.com/s/aHtIW4vmrl-0rUcPI3T7ZQ" target="_blank" rel="noopener noreferrer">处理过期订单，Redis不推荐，那如何做呢？</a></p><h3 id="_1、消息队列" tabindex="-1"><a class="header-anchor" href="#_1、消息队列"><span>1、消息队列</span></a></h3><h3 id="_2、redisson-delayedqueue" tabindex="-1"><a class="header-anchor" href="#_2、redisson-delayedqueue"><span>2、Redisson DelayedQueue</span></a></h3><h3 id="_3、redis-过期监听" tabindex="-1"><a class="header-anchor" href="#_3、redis-过期监听"><span>3、Redis 过期监听</span></a></h3><h3 id="_4、rabbitmq-死信队列" tabindex="-1"><a class="header-anchor" href="#_4、rabbitmq-死信队列"><span>4、RabbitMQ 死信队列</span></a></h3><h3 id="_5、时间轮" tabindex="-1"><a class="header-anchor" href="#_5、时间轮"><span>5、时间轮</span></a></h3><h2 id="三、如何实现自动登录功能" tabindex="-1"><a class="header-anchor" href="#三、如何实现自动登录功能"><span>三、如何实现自动登录功能？</span></a></h2><p><a href="https://docs.pingcode.com/baike/2210471" target="_blank" rel="noopener noreferrer">https://docs.pingcode.com/baike/2210471</a></p><h2 id="四、对外的api安全问题如何保证" tabindex="-1"><a class="header-anchor" href="#四、对外的api安全问题如何保证"><span>四、对外的Api安全问题如何保证？</span></a></h2><p>Todo 按照自己的理解实现：</p><p><a href="https://mp.weixin.qq.com/s/kZZMQcAQh4XLF8sgsxT__g" target="_blank" rel="noopener noreferrer">Spring Cloud微服务，如何保证对外接口的安全？</a></p><h2 id="五、基于阻塞队列实现生产者和消费者模型" tabindex="-1"><a class="header-anchor" href="#五、基于阻塞队列实现生产者和消费者模型"><span>五、基于阻塞队列实现生产者和消费者模型</span></a></h2><blockquote><p>参考地址：<a href="https://blog.csdn.net/m0_73381672/article/details/133690633" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/m0_73381672/article/details/133690633</a></p></blockquote><p>核心方法代码：</p><p><a href="https://gitee.com/hello0709/clarence-java/raw/master/basic/src/main/java/com/dora/basic/juc/blockqueue/MyBlockingQueue.java" target="_blank" rel="noopener noreferrer">MyBlockingQueue</a></p><p>测试运行代码：</p><p><a href="https://gitee.com/hello0709/clarence-java/raw/master/basic/src/main/java/com/dora/basic/juc/blockqueue/Test.java" target="_blank" rel="noopener noreferrer">MyBlockingQueue.Test</a></p><h2 id="六、如何设计一个高并发系统" tabindex="-1"><a class="header-anchor" href="#六、如何设计一个高并发系统"><span>六、如何设计一个高并发系统？</span></a></h2>',23)),i("p",null,[e[1]||(e[1]=n("解答：")),t(r,{to:"/currency/4_high_concurrency_sys"},{default:h(()=>e[0]||(e[0]=[n("高并发-如何设计一个高并发系统？")])),_:1})]),e[3]||(e[3]=a('<h2 id="七、分布式场景下是否适用-synchronized-加锁机制" tabindex="-1"><a class="header-anchor" href="#七、分布式场景下是否适用-synchronized-加锁机制"><span>七、分布式场景下是否适用 synchronized 加锁机制？</span></a></h2><p>解答：<a href="https://mp.weixin.qq.com/s/IGS_8pIc2wSKN88eMEJmSg" target="_blank" rel="noopener noreferrer">分布式场景下是否适用 synchronized 加锁机制？</a></p><h2 id="八、100-亿分库分表-如何设计" tabindex="-1"><a class="header-anchor" href="#八、100-亿分库分表-如何设计"><span>八、100 亿分库分表 如何设计？</span></a></h2><p>解答：<a href="https://mp.weixin.qq.com/s/xQtKtaLG8xRMbK-8b3Rzuw" target="_blank" rel="noopener noreferrer">携程面试：100 亿分库分表 如何设计？</a></p>',4))])}const _=l(d,[["render",p],["__file","0_scene.html.vue"]]),b=JSON.parse('{"path":"/scene/0_scene.html","title":"常见的场景问题","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、分布式系统主键如何处理？","slug":"一、分布式系统主键如何处理","link":"#一、分布式系统主键如何处理","children":[{"level":3,"title":"1、节点生成 or 主键服务？","slug":"_1、节点生成-or-主键服务","link":"#_1、节点生成-or-主键服务","children":[]},{"level":3,"title":"2、主键类型的选择？","slug":"_2、主键类型的选择","link":"#_2、主键类型的选择","children":[]}]},{"level":2,"title":"二、针对于过期的订单，如何处理？","slug":"二、针对于过期的订单-如何处理","link":"#二、针对于过期的订单-如何处理","children":[{"level":3,"title":"1、消息队列","slug":"_1、消息队列","link":"#_1、消息队列","children":[]},{"level":3,"title":"2、Redisson DelayedQueue","slug":"_2、redisson-delayedqueue","link":"#_2、redisson-delayedqueue","children":[]},{"level":3,"title":"3、Redis 过期监听","slug":"_3、redis-过期监听","link":"#_3、redis-过期监听","children":[]},{"level":3,"title":"4、RabbitMQ 死信队列","slug":"_4、rabbitmq-死信队列","link":"#_4、rabbitmq-死信队列","children":[]},{"level":3,"title":"5、时间轮","slug":"_5、时间轮","link":"#_5、时间轮","children":[]}]},{"level":2,"title":"三、如何实现自动登录功能？","slug":"三、如何实现自动登录功能","link":"#三、如何实现自动登录功能","children":[]},{"level":2,"title":"四、对外的Api安全问题如何保证？","slug":"四、对外的api安全问题如何保证","link":"#四、对外的api安全问题如何保证","children":[]},{"level":2,"title":"五、基于阻塞队列实现生产者和消费者模型","slug":"五、基于阻塞队列实现生产者和消费者模型","link":"#五、基于阻塞队列实现生产者和消费者模型","children":[]},{"level":2,"title":"六、如何设计一个高并发系统？","slug":"六、如何设计一个高并发系统","link":"#六、如何设计一个高并发系统","children":[]},{"level":2,"title":"七、分布式场景下是否适用 synchronized 加锁机制？","slug":"七、分布式场景下是否适用-synchronized-加锁机制","link":"#七、分布式场景下是否适用-synchronized-加锁机制","children":[]},{"level":2,"title":"八、100 亿分库分表 如何设计？","slug":"八、100-亿分库分表-如何设计","link":"#八、100-亿分库分表-如何设计","children":[]}],"git":{"updatedTime":1743389279000,"contributors":[{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":4,"url":"https://github.com/Clarence"},{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":4,"url":"https://github.com/hanchen"},{"name":"hello0709","username":"hello0709","email":"1154937362@qq.com","commits":3,"url":"https://github.com/hello0709"}]},"filePathRelative":"scene/0_scene.md"}');export{_ as comp,b as data};
