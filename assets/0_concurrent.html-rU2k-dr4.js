import{_ as a,c as s,a as e,o as t}from"./app-Bh9oJP5P.js";const c={};function o(l,n){return t(),s("div",null,n[0]||(n[0]=[e(`<h1 id="java-并发" tabindex="-1"><a class="header-anchor" href="#java-并发"><span>Java 并发</span></a></h1><p>参考链接：</p><p><a href="https://gitee.com/Doocs/advanced-java#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener noreferrer">https://gitee.com/Doocs/advanced-java</a></p><p><a href="https://mp.weixin.qq.com/s/jUu1k1oKyzt-4wZyDHJp2w" target="_blank" rel="noopener noreferrer">苏三说技术-并发编程</a></p><p><a href="https://mp.weixin.qq.com/s/eTQwT-zFgHgNVJ_nNAZidw" target="_blank" rel="noopener noreferrer">实现异步的9种方式</a></p><h2 id="一、juc-atomic" tabindex="-1"><a class="header-anchor" href="#一、juc-atomic"><span>一、JUC - Atomic</span></a></h2><p>Java 中的 <code>java.util.concurrent.atomic</code> 包提供了一组<strong>原子变量类</strong>，主要用于<strong>高并发场景下的无锁编程</strong>，比起使用 <code>synchronized</code>，这些类可以提升程序的性能和吞吐量。</p><h3 id="_1、核心思想-cas-compare-and-swap" tabindex="-1"><a class="header-anchor" href="#_1、核心思想-cas-compare-and-swap"><span>1、核心思想：CAS（Compare-And-Swap）</span></a></h3><p>CAS 是实现原子操作的核心：</p><ul><li><strong>比较内存值是否为预期值</strong>，如果是则修改为新值。</li><li>是一种乐观锁机制。</li></ul><h3 id="_2、常用的原子类分类" tabindex="-1"><a class="header-anchor" href="#_2、常用的原子类分类"><span>2、常用的原子类分类</span></a></h3><h4 id="_2-1-基本类型原子类" tabindex="-1"><a class="header-anchor" href="#_2-1-基本类型原子类"><span>2.1. 基本类型原子类</span></a></h4><table><thead><tr><th>类名</th><th>对应类型</th></tr></thead><tbody><tr><td><code>AtomicInteger</code></td><td>int</td></tr><tr><td><code>AtomicLong</code></td><td>long</td></tr><tr><td><code>AtomicBoolean</code></td><td>boolean</td></tr></tbody></table><p><strong>示例：</strong></p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">AtomicInteger</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    counter<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// +1</span></span>
<span class="line">    counter<span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// +5</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-引用类型原子类" tabindex="-1"><a class="header-anchor" href="#_2-2-引用类型原子类"><span>2.2 引用类型原子类</span></a></h4><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td><code>AtomicReference&lt;T&gt;</code></td><td>原子更新引用</td></tr><tr><td><code>AtomicStampedReference&lt;T&gt;</code></td><td>带版本戳，解决ABA问题</td></tr><tr><td><code>AtomicMarkableReference&lt;T&gt;</code></td><td>带布尔标记</td></tr></tbody></table><p><strong>ABA问题解决示例：</strong></p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">AtomicStampedReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ref <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicStampedReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stampHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Integer</span> value <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>stampHolder<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    ref<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> stampHolder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stampHolder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-3-数组原子类" tabindex="-1"><a class="header-anchor" href="#_2-3-数组原子类"><span>2.3 数组原子类</span></a></h4><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td><code>AtomicIntegerArray</code></td><td>原子更新整型数组</td></tr><tr><td><code>AtomicLongArray</code></td><td>原子更新长整型数组</td></tr><tr><td><code>AtomicReferenceArray&lt;T&gt;</code></td><td>原子更新引用数组</td></tr></tbody></table><h4 id="_3-高级类-longadder-longaccumulator" tabindex="-1"><a class="header-anchor" href="#_3-高级类-longadder-longaccumulator"><span>3. 高级类：<code>LongAdder</code> / <code>LongAccumulator</code></span></a></h4><p>为了解决高并发下 <code>AtomicLong</code> 的热点问题，引入了分段累加器：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">LongAdder</span> adder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongAdder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    adder<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 高并发下效率更好</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_4、优缺点对比" tabindex="-1"><a class="header-anchor" href="#_4、优缺点对比"><span>4、优缺点对比</span></a></h3><table><thead><tr><th>特点</th><th>Atomic 原子类</th><th>synchronized</th></tr></thead><tbody><tr><td>是否阻塞</td><td>否（非阻塞）</td><td>是</td></tr><tr><td>性能</td><td>高</td><td>中</td></tr><tr><td>是否公平</td><td>否</td><td>是</td></tr><tr><td>可读性</td><td>一般</td><td>高</td></tr></tbody></table><hr><h3 id="_5、使用建议" tabindex="-1"><a class="header-anchor" href="#_5、使用建议"><span>5、使用建议</span></a></h3><ul><li>在<strong>并发量大</strong>但<strong>冲突概率低</strong>的场景中使用 Atomic 类。</li><li>如果涉及多个变量的原子性，则需要使用 <code>synchronized</code> 或 <code>Lock</code>。</li></ul><h2 id="juc-lock" tabindex="-1"><a class="header-anchor" href="#juc-lock"><span>JUC - LOCK</span></a></h2><h3 id="reentrantlock-可重入锁" tabindex="-1"><a class="header-anchor" href="#reentrantlock-可重入锁"><span>ReentrantLock（可重入锁）</span></a></h3><h3 id="countdownlatch-cyclicbarrier" tabindex="-1"><a class="header-anchor" href="#countdownlatch-cyclicbarrier"><span>CountDownLatch / CyclicBarrier</span></a></h3><h3 id="semaphore-信号量" tabindex="-1"><a class="header-anchor" href="#semaphore-信号量"><span>Semaphore（信号量）</span></a></h3><h3 id="blockingqueue-生产者-消费者模式" tabindex="-1"><a class="header-anchor" href="#blockingqueue-生产者-消费者模式"><span>BlockingQueue（生产者-消费者模式）</span></a></h3><h3 id="concurrenthashmap-并发容器" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-并发容器"><span>ConcurrentHashMap 并发容器</span></a></h3><h2 id="juc-fork-join" tabindex="-1"><a class="header-anchor" href="#juc-fork-join"><span>JUC - Fork/Join</span></a></h2><h3 id="fork-join-工作窃取算法" tabindex="-1"><a class="header-anchor" href="#fork-join-工作窃取算法"><span>Fork/Join 工作窃取算法</span></a></h3><h3 id="任务拆分与合并" tabindex="-1"><a class="header-anchor" href="#任务拆分与合并"><span>任务拆分与合并</span></a></h3><h2 id="juc-completablefuture-与异步编程" tabindex="-1"><a class="header-anchor" href="#juc-completablefuture-与异步编程"><span>JUC - CompletableFuture 与异步编程</span></a></h2><p><a href="https://mp.weixin.qq.com/s/_Qre84czFDNNQVQArbY2UA" target="_blank" rel="noopener noreferrer">CompletableFuture使用的6个坑</a></p><h3 id="future-vs-completablefuture" tabindex="-1"><a class="header-anchor" href="#future-vs-completablefuture"><span>Future vs CompletableFuture</span></a></h3><h3 id="异步任务组合" tabindex="-1"><a class="header-anchor" href="#异步任务组合"><span>异步任务组合</span></a></h3>`,43)]))}const r=a(c,[["render",o],["__file","0_concurrent.html.vue"]]),i=JSON.parse('{"path":"/concurrent/0_concurrent.html","title":"Java 并发","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、JUC - Atomic","slug":"一、juc-atomic","link":"#一、juc-atomic","children":[{"level":3,"title":"1、核心思想：CAS（Compare-And-Swap）","slug":"_1、核心思想-cas-compare-and-swap","link":"#_1、核心思想-cas-compare-and-swap","children":[]},{"level":3,"title":"2、常用的原子类分类","slug":"_2、常用的原子类分类","link":"#_2、常用的原子类分类","children":[]},{"level":3,"title":"4、优缺点对比","slug":"_4、优缺点对比","link":"#_4、优缺点对比","children":[]},{"level":3,"title":"5、使用建议","slug":"_5、使用建议","link":"#_5、使用建议","children":[]}]},{"level":2,"title":"JUC - LOCK","slug":"juc-lock","link":"#juc-lock","children":[{"level":3,"title":"ReentrantLock（可重入锁）","slug":"reentrantlock-可重入锁","link":"#reentrantlock-可重入锁","children":[]},{"level":3,"title":"CountDownLatch / CyclicBarrier","slug":"countdownlatch-cyclicbarrier","link":"#countdownlatch-cyclicbarrier","children":[]},{"level":3,"title":"Semaphore（信号量）","slug":"semaphore-信号量","link":"#semaphore-信号量","children":[]},{"level":3,"title":"BlockingQueue（生产者-消费者模式）","slug":"blockingqueue-生产者-消费者模式","link":"#blockingqueue-生产者-消费者模式","children":[]},{"level":3,"title":"ConcurrentHashMap 并发容器","slug":"concurrenthashmap-并发容器","link":"#concurrenthashmap-并发容器","children":[]}]},{"level":2,"title":"JUC - Fork/Join","slug":"juc-fork-join","link":"#juc-fork-join","children":[{"level":3,"title":"Fork/Join 工作窃取算法","slug":"fork-join-工作窃取算法","link":"#fork-join-工作窃取算法","children":[]},{"level":3,"title":"任务拆分与合并","slug":"任务拆分与合并","link":"#任务拆分与合并","children":[]}]},{"level":2,"title":"JUC - CompletableFuture 与异步编程","slug":"juc-completablefuture-与异步编程","link":"#juc-completablefuture-与异步编程","children":[{"level":3,"title":"Future vs CompletableFuture","slug":"future-vs-completablefuture","link":"#future-vs-completablefuture","children":[]},{"level":3,"title":"异步任务组合","slug":"异步任务组合","link":"#异步任务组合","children":[]}]}],"git":{"updatedTime":1745202482000,"contributors":[{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":4,"url":"https://github.com/hanchen"},{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":7,"url":"https://github.com/Clarence"},{"name":"hello0709","username":"hello0709","email":"1154937362@qq.com","commits":2,"url":"https://github.com/hello0709"}]},"filePathRelative":"concurrent/0_concurrent.md"}');export{r as comp,i as data};
