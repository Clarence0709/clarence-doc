import{_ as n,c as a,b as e,o as i}from"./app-CGOuCsDt.js";const l="/clarence-doc/assets/redis_distribute_lock-BtQSjvk2.png",t="/clarence-doc/assets/all_copy-B_F6H1jn.png",c="/clarence-doc/assets/continue_copy-DhB_USxq.png",p={};function d(r,s){return i(),a("div",null,s[0]||(s[0]=[e('<h1 id="redis相关" tabindex="-1"><a class="header-anchor" href="#redis相关"><span>Redis相关</span></a></h1><p>这是关于数据结构的内容...</p><h2 id="redis线程模型" tabindex="-1"><a class="header-anchor" href="#redis线程模型"><span>Redis线程模型</span></a></h2><p>介绍线程模型的内容...</p><h2 id="redis分布式锁" tabindex="-1"><a class="header-anchor" href="#redis分布式锁"><span>Redis分布式锁</span></a></h2><p>为了更好的理解分布式锁的原理，我这边自己画张图通过这张图来分析：</p><p><img src="'+l+`" alt="img.png"></p><h3 id="_1、加锁机制" tabindex="-1"><a class="header-anchor" href="#_1、加锁机制"><span>1、加锁机制</span></a></h3><p>线程去获取锁，获取成功: 执行 lua脚本，保存数据到 redis数据库。</p><p>线程去获取锁，获取失败: 一直通过 while循环尝试获取锁，获取成功后，执行 lua脚本，保存数据到 redis数据库。</p><h3 id="_2、watch-dog自动延期机制" tabindex="-1"><a class="header-anchor" href="#_2、watch-dog自动延期机制"><span>2、Watch dog自动延期机制</span></a></h3><p>在一个分布式环境下，假如一个线程获得锁后，突然服务器宕机了，那么这个时候在一定时间后这个锁会自动释放，你也可以设置锁的有效时间(不设置默认30秒），这样的目的主要是防止死锁的发生。</p><p>但在实际开发中会有下面一种情况:</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">//设置锁1秒过期</span></span>
<span class="line">redissonLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token string">&quot;redisson&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token doc-comment comment">/**</span>
<span class="line">* 业务逻辑需要咨询2秒</span>
<span class="line">*/</span></span>
<span class="line">redissonLock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token string">&quot;redisson&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token doc-comment comment">/**</span>
<span class="line">* 线程1 进来获得锁后，线程一切正常并没有宕机，但它的业务逻辑需要执行2秒，这就会有个问题，</span>
<span class="line">* 在 线程1 执行1秒后,这个锁就自动过期了，那么这个时候 线程2 进来了。那么就存在 线程1和线程2 </span>
<span class="line">* 同时在这段业务逻辑里执行代码，这当然是不合理的。而且如果是这种情况，那么在解锁时系统会抛异常，</span>
<span class="line">* 因为解锁和加锁已经不是同一线程了，具体后面代码演示。</span>
<span class="line">*/</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以这个时候看门狗就出现了，它的作用就是 线程1 业务还没有执行完，时间就过了，线程1 还想持有锁的话，就会启动一个 watch dog后台线程，不断的延长锁 key的生存时间。</p><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>注意：正常这个看门狗线程是不启动的，还有就是这个看门狗启动后对整体性能也会有一定影响，所以<strong>不建议开启看门狗</strong>。</p></div><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>todo: to be continue...</p></div><h2 id="redis主从复制原理" tabindex="-1"><a class="header-anchor" href="#redis主从复制原理"><span>Redis主从复制原理</span></a></h2><h3 id="_1、全量复制" tabindex="-1"><a class="header-anchor" href="#_1、全量复制"><span>1、全量复制</span></a></h3><p><img src="`+t+'" alt="img.png"></p><h3 id="_2、断点续传" tabindex="-1"><a class="header-anchor" href="#_2、断点续传"><span>2、断点续传</span></a></h3><p><img src="'+c+'" alt="img_1.png"></p>',22)]))}const h=n(p,[["render",d],["__file","1_redis.html.vue"]]),u=JSON.parse('{"path":"/cache/1_redis.html","title":"Redis相关","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Redis线程模型","slug":"redis线程模型","link":"#redis线程模型","children":[]},{"level":2,"title":"Redis分布式锁","slug":"redis分布式锁","link":"#redis分布式锁","children":[{"level":3,"title":"1、加锁机制","slug":"_1、加锁机制","link":"#_1、加锁机制","children":[]},{"level":3,"title":"2、Watch dog自动延期机制","slug":"_2、watch-dog自动延期机制","link":"#_2、watch-dog自动延期机制","children":[]}]},{"level":2,"title":"Redis主从复制原理","slug":"redis主从复制原理","link":"#redis主从复制原理","children":[{"level":3,"title":"1、全量复制","slug":"_1、全量复制","link":"#_1、全量复制","children":[]},{"level":3,"title":"2、断点续传","slug":"_2、断点续传","link":"#_2、断点续传","children":[]}]}],"git":{"updatedTime":1738942143000,"contributors":[{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":2,"url":"https://github.com/hanchen"},{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":1,"url":"https://github.com/Clarence"}]},"filePathRelative":"cache/1_redis.md"}');export{h as comp,u as data};
