import{_ as n,c as a,a as r,o as t}from"./app-Bh36yroc.js";const s="/clarence-java-doc/assets/clash_config-CwfpHvCj.png",i="/clarence-java-doc/assets/bridge-B03reanc.png",c="/clarence-java-doc/assets/host-CkGhpnHK.png",o="/clarence-java-doc/assets/container-BEMtEPlk.png",l="/clarence-java-doc/assets/container_warning-DhX3PrEY.png",p={};function h(d,e){return t(),a("div",null,e[0]||(e[0]=[r('<h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker"><span>Docker</span></a></h1><h2 id="一、docker-镜像问题" tabindex="-1"><a class="header-anchor" href="#一、docker-镜像问题"><span>一、Docker 镜像问题</span></a></h2><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>2024年6月开始，国内的常用 daemon.json 地址失效</p></div><h3 id="_1、可用网址汇总" tabindex="-1"><a class="header-anchor" href="#_1、可用网址汇总"><span>1、可用网址汇总</span></a></h3><p>点击下方地址查看教程：</p><p><a href="https://1ms.run" target="_blank" rel="noopener noreferrer">https://1ms.run</a></p><p><a href="https://xuanyuan.me/" target="_blank" rel="noopener noreferrer">https://xuanyuan.me/</a></p><h3 id="_2、常用解决方案" tabindex="-1"><a class="header-anchor" href="#_2、常用解决方案"><span>2、常用解决方案</span></a></h3><h4 id="_2-1、魔法下载后-手动上传-最笨方案" tabindex="-1"><a class="header-anchor" href="#_2-1、魔法下载后-手动上传-最笨方案"><span>2.1、魔法下载后，手动上传（最笨方案）</span></a></h4><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>这是本人开始的思路，最终发现docker hub 并不支持此方案，除非使用 <strong>Docker Registry</strong> 进行交互来获得镜像层的内容并手动下载，但这种方法复杂且不常用</p></div><h4 id="_2-2、基于基线环境重新导入" tabindex="-1"><a class="header-anchor" href="#_2-2、基于基线环境重新导入"><span>2.2、基于基线环境重新导入</span></a></h4><p>文如其意，直接使用正式环境中已经存在的镜像，随后将 docker image 导出，再次导入即可；</p><h4 id="_2-3、魔法代理方式直接下载" tabindex="-1"><a class="header-anchor" href="#_2-3、魔法代理方式直接下载"><span>2.3、魔法代理方式直接下载</span></a></h4><ul><li>VMware 中的 Docker 使用魔法方式</li></ul><div class="hint-container tip"><p class="hint-container-title">必要前提条件</p><p>Vmware使用NAT模式，保证主机和虚拟机在一个局域网下</p></div><p><a href="https://clashcn.com/" target="_blank" rel="noopener noreferrer">Clash</a> 的配置如下：</p><p><img src="'+s+'" alt="img.png"></p><div class="hint-container tip"><p class="hint-container-title">建议</p><p>设置完成后，建议清空 daemon.json 内容，当然也可以保留（不过会使得Docker去所有的daemon地址搜索，降低 pull 速度）</p></div><ul><li>Hyper-V 中的Docker使用魔法方式</li></ul><p>使用clash，保证和 Hyper-V 宿主机在同个局域网即可，原理与 <strong>VMware</strong> 相同</p><ul><li>Docker直接使用代理方式实现</li></ul><div class="hint-container tip"><p class="hint-container-title">Todo</p><p>使用指定地址的代理实现，目前只是构思阶段，未完待续</p></div><h2 id="二、docker-网络详解" tabindex="-1"><a class="header-anchor" href="#二、docker-网络详解"><span>二、Docker 网络详解</span></a></h2><p>默认情况下，<strong>Docker0</strong>为默认新增的<strong>Bridge</strong>网络，<strong>Docker0</strong>就是桥，将其所有的container链接起来，Docker的container可以直接访问外部网络， 内部之间的网络也是可以ping通的（默认不能ping主机名）；</p><h3 id="_1、bridge" tabindex="-1"><a class="header-anchor" href="#_1、bridge"><span>1、Bridge</span></a></h3><p><img src="'+i+'" alt="img.png"></p><h3 id="_2、host" tabindex="-1"><a class="header-anchor" href="#_2、host"><span>2、Host</span></a></h3><p>注意：此模式下，各个容器不存在IP地址，只能通过端口或其他机制进行通信；</p><p><img src="'+c+'" alt="img_1.png"></p><h3 id="_3、none" tabindex="-1"><a class="header-anchor" href="#_3、none"><span>3、None</span></a></h3><p>内部容器，没有网卡、路由、防火墙、IP、网关，端口等</p><h3 id="_4、container" tabindex="-1"><a class="header-anchor" href="#_4、container"><span>4、Container</span></a></h3><p>bridge和Host模式的结合体，存在Docker0网络，后续指定其网关；</p><p><img src="'+o+'" alt="img_2.png"></p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>这种方式官方已不推荐使用，并且在未来版本可能会被移除，所以这里不作为重点讲解，感兴趣可自行了解。</p><p>官网警告信息：<a href="https://docs.docker.com/network" target="_blank" rel="noopener noreferrer">https://docs.docker.com/network</a></p></div><p><img src="'+l+'" alt="img_3.png"></p>',36)]))}const _=n(p,[["render",h],["__file","3_docker.html.vue"]]),m=JSON.parse('{"path":"/container/3_docker.html","title":"Docker","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、Docker 镜像问题","slug":"一、docker-镜像问题","link":"#一、docker-镜像问题","children":[{"level":3,"title":"1、可用网址汇总","slug":"_1、可用网址汇总","link":"#_1、可用网址汇总","children":[]},{"level":3,"title":"2、常用解决方案","slug":"_2、常用解决方案","link":"#_2、常用解决方案","children":[]}]},{"level":2,"title":"二、Docker 网络详解","slug":"二、docker-网络详解","link":"#二、docker-网络详解","children":[{"level":3,"title":"1、Bridge","slug":"_1、bridge","link":"#_1、bridge","children":[]},{"level":3,"title":"2、Host","slug":"_2、host","link":"#_2、host","children":[]},{"level":3,"title":"3、None","slug":"_3、none","link":"#_3、none","children":[]},{"level":3,"title":"4、Container","slug":"_4、container","link":"#_4、container","children":[]}]}],"git":{"updatedTime":1742735410000,"contributors":[{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":1,"url":"https://github.com/hanchen"},{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":7,"url":"https://github.com/Clarence"},{"name":"hello0709","username":"hello0709","email":"1154937362@qq.com","commits":1,"url":"https://github.com/hello0709"}]},"filePathRelative":"container/3_docker.md"}');export{_ as comp,m as data};
