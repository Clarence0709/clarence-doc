import{_ as o,c,b as l,d as e,e as p,f as a,a as s,r as i,o as u}from"./app-DZLbke4Q.js";const r="/clarence-doc/assets/hashmap_hash_conflict-DfcWWAIJ.png",d="/clarence-doc/assets/LinkedHashMap-uNfJhtFw.png",k="/clarence-doc/assets/TreeMap-RKRumpct.png",h="/clarence-doc/assets/threadlocal_usage-DJvxl6vh.png",v="/clarence-doc/assets/threadlocal_structure-Chz4M1CP.png",m={};function g(b,n){const t=i("RouteLink");return u(),c("div",null,[n[27]||(n[27]=l('<h1 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础"><span>Java基础</span></a></h1><h2 id="一、hashmap分析" tabindex="-1"><a class="header-anchor" href="#一、hashmap分析"><span>一、Hashmap分析</span></a></h2><p>HashMap 是一种基于哈希表的数据结构，它实现了 Map 接口，用于存储键值对 (key-value)。其基本原理如下：</p><h3 id="_1、-哈希表-hash-table" tabindex="-1"><a class="header-anchor" href="#_1、-哈希表-hash-table"><span>1、 哈希表（Hash Table）</span></a></h3><p>HashMap 是基于哈希表实现的，哈希表的基本思想是通过将数据的键值对映射到一个数组的索引位置上来提高数据查找的效率。具体流程如下：</p><ul><li><p><strong>哈希函数</strong>： HashMap 使用哈希函数将键（key）映射到数组的索引位置。哈希函数的目的是通过计算一个值，将不同的键映射到哈希表中的位置。</p></li><li><p><strong>数组</strong>： 哈希表内部使用一个数组来存储数据。数组中的每个元素存储一个链表（或者在 Java 8 后是</p></li></ul>',6)),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[0]||(n[0]=[a("红黑树")])),_:1}),n[28]||(n[28]=a("），用于处理哈希冲突。")),n[29]||(n[29]=s("h3",{id:"_2、-哈希冲突",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_2、-哈希冲突"},[s("span",null,"2、 哈希冲突")])],-1)),n[30]||(n[30]=s("p",null,"由于哈希函数不可能做到完全唯一的映射，不同的键可能会被映射到相同的索引，这种情况称为哈希冲突。HashMap 通过以下方式解决哈希冲突：",-1)),s("ul",null,[s("li",null,[s("p",null,[n[2]||(n[2]=s("strong",null,"链表法（链式哈希）",-1)),n[3]||(n[3]=a("： 在发生冲突的情况下，HashMap 会将冲突的键值对存储到一个链表中 （或者 ")),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[1]||(n[1]=[a("红黑树")])),_:1}),n[4]||(n[4]=a("）。 当多个元素映射到同一个索引位置时，它们会形成一个链表。"))])]),s("li",null,[s("p",null,[s("strong",null,[e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[5]||(n[5]=[a("红黑树")])),_:1}),n[6]||(n[6]=a("法"))]),n[8]||(n[8]=a("： 在 Java 8 及以后的版本中， 如果链表的长度超过一定阈值（默认为 8），HashMap 会将链表转化为")),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[7]||(n[7]=[a("红黑树")])),_:1}),n[9]||(n[9]=a("，以提高查询效率。"))])])]),n[31]||(n[31]=l('<p><img src="'+r+'" alt="img.png"></p><h3 id="_3、-扩容机制" tabindex="-1"><a class="header-anchor" href="#_3、-扩容机制"><span>3、 扩容机制</span></a></h3><p>当 HashMap 中的元素过多时，哈希表的负载因子（load factor）可能会达到阈值，导致哈希表的存储效率降低。默认情况下，负载因子为 0.75。 <strong>当元素个数超过当前容量 * 负载因子时，HashMap 会进行扩容</strong>（通常是原数组大小的 2 倍）。</p><p>扩容过程中，所有元素的哈希值会被重新计算，并重新放置到新的数组位置。这是因为<strong>哈希表的大小发生变化，导致原先的索引位置不再适用</strong>。</p><h3 id="_4、-时间复杂度" tabindex="-1"><a class="header-anchor" href="#_4、-时间复杂度"><span>4、 时间复杂度</span></a></h3><ul><li><strong>查找、插入、删除 时间复杂度</strong>：</li></ul>',6)),s("p",null,[n[11]||(n[11]=a("在理想情况下，哈希表的查找、插入和删除操作的时间复杂度为 O(1)。但是，如果发生哈希冲突，性能会退化到 O(n)（链表长度为 n 时）。 使用 ")),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[10]||(n[10]=[a("红黑树")])),_:1}),n[12]||(n[12]=a("优化后，最坏情况下时间复杂度为 O(log n)。"))]),n[32]||(n[32]=l('<ul><li><strong>扩容操作的时间复杂度</strong>：</li></ul><p>扩容是一个相对耗时的操作，时间复杂度为 O(n)，但扩容操作是按需进行的，不是频繁发生，因此平均而言，HashMap 的操作仍然是 O(1)。</p><h3 id="_5、-关键特点" tabindex="-1"><a class="header-anchor" href="#_5、-关键特点"><span>5、 关键特点</span></a></h3><ul><li>非线程安全：HashMap 不是线程安全的，如果在多线程环境下使用，需要考虑同步问题。</li><li>允许 null 键和 null 值：HashMap 允许一个 null 键和多个 null 值。</li><li>元素顺序不保证：HashMap 不保证键值对的顺序，因为它是基于哈希函数计算索引的，顺序是无序的。如果需要顺序，可以使用 LinkedHashMap</li></ul><h2 id="二、linkedhashmap分析" tabindex="-1"><a class="header-anchor" href="#二、linkedhashmap分析"><span>二、LinkedHashMap分析</span></a></h2><h3 id="_1、类继承关系" tabindex="-1"><a class="header-anchor" href="#_1、类继承关系"><span>1、类继承关系</span></a></h3><p>LinkedHashMap继承了HashMap类，是HashMap的子类，LinkedHashMap的大多数方法的实现直接使用了父类HashMap的方法, LinkedHashMap可以说是HashMap和LinkedList的集合体，<strong>既使用了HashMap的数据结构，又借用了LinkedList双向链表的结构保存了记录的插入顺序， 在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</strong></p><p><img src="'+d+`" alt=""></p><h3 id="_2、基本原理" tabindex="-1"><a class="header-anchor" href="#_2、基本原理"><span>2、基本原理</span></a></h3><p>Todo 彻底精通后完成。。。</p><h2 id="三、concurrenthashmap分析" tabindex="-1"><a class="header-anchor" href="#三、concurrenthashmap分析"><span>三、ConcurrentHashMap分析</span></a></h2><h3 id="_1、concurrenthashmap基本特性" tabindex="-1"><a class="header-anchor" href="#_1、concurrenthashmap基本特性"><span>1、ConcurrentHashMap基本特性</span></a></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>采用 CAS + 自旋锁 替代 synchronized，减少锁竞争</td></tr><tr><td><strong>高并发</strong></td><td>读操作无锁，写操作局部加锁，避免全局锁的性能瓶颈</td></tr><tr><td><strong>不支持 null</strong></td><td>key 和 value 都 不能为 null，防止 NullPointerException</td></tr><tr><td><strong>比 Hashtable 性能高</strong></td><td>Hashtable 使用 synchronized 进行全表加锁，而 ConcurrentHashMap 采用 分段锁机制（JDK 1.7）和 CAS + 自旋锁（JDK 1.8）</td></tr></tbody></table><h3 id="_2、jdk-1-7-和-1-8-的区别" tabindex="-1"><a class="header-anchor" href="#_2、jdk-1-7-和-1-8-的区别"><span>2、JDK 1.7 和 1.8 的区别</span></a></h3><table><thead><tr><th><strong>版本</strong></th><th><strong>JDK 1.7</strong></th><th><strong>JDK 1.8 及以后</strong></th></tr></thead><tbody><tr><td><strong>底层数据结构</strong></td><td>Segment（分段锁） + 数组 + 链表</td><td>数组 + 链表 + 红黑树（大于 8 个元素）</td></tr><tr><td><strong>加锁方式</strong></td><td>分段锁（Segment 继承 ReentrantLock）</td><td>CAS + 自旋锁 + synchronized（局部）</td></tr><tr><td><strong>并发控制</strong></td><td>多个 Segment 互不影响</td><td>CAS 方式优化，减少锁竞争</td></tr><tr><td><strong>写入性能</strong></td><td>分段锁，性能较好</td><td>CAS + 局部锁，性能更高</td></tr><tr><td><strong>扩容机制</strong></td><td>Segment 级别扩容</td><td>无锁扩容，支持并发扩容</td></tr></tbody></table><ul><li>更多细节，如基本结构，及其方法，研究后再写；</li></ul><h2 id="四、concurrenthashmap为什么放弃分段锁" tabindex="-1"><a class="header-anchor" href="#四、concurrenthashmap为什么放弃分段锁"><span>四、ConcurrentHashMap为什么放弃分段锁？</span></a></h2><h3 id="_1、-jdk-1-7-前分段锁的弊端" tabindex="-1"><a class="header-anchor" href="#_1、-jdk-1-7-前分段锁的弊端"><span>1、 JDK 1.7 前分段锁的弊端</span></a></h3><h4 id="🔴-1-1-扩容性能低" tabindex="-1"><a class="header-anchor" href="#🔴-1-1-扩容性能低"><span>🔴 1.1 扩容性能低</span></a></h4><p>JDK 1.7 ConcurrentHashMap 采用 <strong>分段锁（Segment）</strong>，每个 Segment 维护一个独立的 HashEntry[]，但在 扩容 时：</p><ul><li><p>需要 <strong>对整个 Segment 加锁</strong>，导致其他线程无法访问该 Segment，影响并发性能。</p></li><li><p><strong>迁移数据需要同步整个 Segment</strong>，多个线程不能同时进行数据迁移。</p></li></ul><h4 id="🔴-1-2-空间浪费" tabindex="-1"><a class="header-anchor" href="#🔴-1-2-空间浪费"><span>🔴 1.2 空间浪费</span></a></h4><ul><li>ConcurrentHashMap 预先分配多个 Segment，即使有的 Segment 为空，仍然占用内存，导致 空间利用率低。</li></ul><h4 id="🔴-1-3-结构复杂-代码难维护" tabindex="-1"><a class="header-anchor" href="#🔴-1-3-结构复杂-代码难维护"><span>🔴 1.3 结构复杂，代码难维护</span></a></h4><ul><li><p>Segment <strong>继承 ReentrantLock，导致 锁管理复杂</strong>，增加了不必要的开销。</p></li><li><p>Segment 结构导致 put 操作需要 <strong>两次 hash 计算</strong>（一次计算 Segment 索引，一次计算 Entry 索引），影响性能：</p></li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"> <span class="token comment">// 找到 Segment</span></span>
<span class="line"><span class="token keyword">int</span> segmentIndex <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&gt;&gt;&gt;</span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask<span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 在该 Segment 内部查找</span></span>
<span class="line"><span class="token keyword">int</span> bucketIndex <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>segment<span class="token punctuation">.</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、-jdk-1-8-后新方案" tabindex="-1"><a class="header-anchor" href="#_2、-jdk-1-8-后新方案"><span>2、 JDK 1.8 后新方案</span></a></h3><p>JDK 1.8 直接去掉 Segment，采用 <strong>数组 + 链表 + 红黑树</strong> 结构，结合 CAS + synchronized 局部锁，实现更高效的并发控制：</p><h4 id="✅-2-1-采用-cas-无锁优化" tabindex="-1"><a class="header-anchor" href="#✅-2-1-采用-cas-无锁优化"><span>✅ 2.1 采用 CAS 无锁优化</span></a></h4><ul><li>CAS（Compare And Swap） 是一种 乐观锁，当多个线程竞争同一个 Node 插入时，采用 CAS 方式写入，避免不必要的锁竞争：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这样，当 Node 为空时，线程可以 <strong>无锁写入</strong>，提高吞吐量。</li></ul><h4 id="✅-2-2-采用-synchronized-代替-reentrantlock" tabindex="-1"><a class="header-anchor" href="#✅-2-2-采用-synchronized-代替-reentrantlock"><span>✅ 2.2 采用 synchronized 代替 ReentrantLock</span></a></h4><ul><li>由于 synchronized 在 JDK 1.8 中已优化（锁粗化、锁消除、偏向锁等），其性能接近 ReentrantLock，因此 JDK 1.8 直接使用 synchronized 进行局部加锁：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// f 是桶中的第一个节点</span></span>
<span class="line"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">putValUnderLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>只锁定当前桶位（Node[] 数组中的一个索引），避免对整个 Map 加锁，减少竞争。</li></ul><h4 id="✅-2-3-红黑树优化-提升查询性能" tabindex="-1"><a class="header-anchor" href="#✅-2-3-红黑树优化-提升查询性能"><span>✅ 2.3 红黑树优化，提升查询性能</span></a></h4><ul><li>如果某个桶的链表长度 超过 8，则转换为 红黑树，提升查询效率：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>链表查询 O(n) → 红黑树查询 O(log n)，减少链表查找的性能损耗。</li></ul><h4 id="✅-2-4-支持无锁扩容" tabindex="-1"><a class="header-anchor" href="#✅-2-4-支持无锁扩容"><span>✅ 2.4 支持无锁扩容</span></a></h4><ul><li>多个线程可以并发迁移数据，提升扩容效率，避免 Segment 级别的全局锁：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>sizeCtl <span class="token operator">&lt;</span> table<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">0.75</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 进行无锁扩容</span></span>
<span class="line">    <span class="token function">transferNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>采用 <strong>分批次迁移</strong>，多个线程 并行扩容，减少停顿时间。</li></ul><h2 id="四、hashmap、linkedhashmap、concurrenthashmap对比" tabindex="-1"><a class="header-anchor" href="#四、hashmap、linkedhashmap、concurrenthashmap对比"><span>四、HashMap、LinkedHashMap、ConcurrentHashMap对比</span></a></h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>HashMap</strong></th><th><strong>LinkedHashMap</strong></th><th><strong>ConcurrentHashMap</strong></th></tr></thead><tbody><tr><td><strong>底层数据结构</strong></td><td>哈希表（数组 + 链表/红黑树）</td><td>哈希表 + 双向链表</td><td>哈希表（分段锁、CAS 机制）</td></tr><tr><td><strong>key 是否有序</strong></td><td>❌ 无序</td><td>✅ 按插入顺序排序</td><td>❌ 无序</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(1) 平均，O(n) 最坏</td><td>O(1) 平均，O(n) 最坏</td><td>O(1) 平均，O(n) 最坏</td></tr><tr><td><strong>是否允许 null key</strong></td><td>✅ 允许</td><td>✅ 允许</td><td>❌ 不允许</td></tr><tr><td><strong>是否允许 null value</strong></td><td>✅ 允许</td><td>✅ 允许</td><td>❌ 不允许</td></tr><tr><td><strong>线程安全</strong></td><td>❌ 非线程安全</td><td>❌ 非线程安全</td><td>✅ 线程安全</td></tr><tr><td><strong>适用场景</strong></td><td>快速查找、无序存储、大量数据</td><td>需要按插入顺序遍历的场景</td><td>并发环境下的高效哈希映射</td></tr><tr><td><strong>主要应用</strong></td><td>缓存、映射查找、对象存储</td><td>LRU 缓存、访问顺序存储</td><td>高并发场景，如缓存、线程池</td></tr></tbody></table><h2 id="三、treemap分析" tabindex="-1"><a class="header-anchor" href="#三、treemap分析"><span>三、TreeMap分析</span></a></h2><h3 id="_1、源码分析" tabindex="-1"><a class="header-anchor" href="#_1、源码分析"><span>1、源码分析</span></a></h3><ul><li>类关联图如下所示：</li></ul><p><img src="`+k+'" alt="image.png"></p><ul><li>TreeMap 的核心特点</li></ul>',51)),s("table",null,[n[21]||(n[21]=s("thead",null,[s("tr",null,[s("th",null,"特性"),s("th",null,"说明")])],-1)),s("tbody",null,[s("tr",null,[n[15]||(n[15]=s("td",null,"底层实现",-1)),s("td",null,[e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[13]||(n[13]=[a("红黑树")])),_:1}),n[14]||(n[14]=a("（Red-Black Tree），是一种自平衡二叉搜索树（BST）"))])]),n[16]||(n[16]=s("tr",null,[s("td",null,"排序方式"),s("td",null,"默认按 key 的 自然顺序（Comparable） 排序，也可以传入 自定义 Comparator")],-1)),n[17]||(n[17]=s("tr",null,[s("td",null,"时间复杂度"),s("td",null,"O(log n)（增、删、查）")],-1)),n[18]||(n[18]=s("tr",null,[s("td",null,"是否允许 null key"),s("td",null,"❌ 不允许 null key（会抛 NullPointerException）")],-1)),n[19]||(n[19]=s("tr",null,[s("td",null,"是否允许 null value"),s("td",null,"✅ 允许 null value")],-1)),n[20]||(n[20]=s("tr",null,[s("td",null,"是否线程安全"),s("td",null,"❌ 非线程安全（需要 Collections.synchronizedMap() 保护）")],-1))])]),n[33]||(n[33]=l(`<div class="hint-container important"><p class="hint-container-title">使用途径</p><p>适用于需要 &quot;<strong>自动排序</strong>&quot; 和 &quot;<strong>范围查询</strong>&quot; 的场景。</p></div><p>1、适用场景：数据存储时要求按照 key 进行排序，方便后续查询和展示</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> productMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">productMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">102</span><span class="token punctuation">,</span> <span class="token string">&quot;iPhone&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">productMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token string">&quot;Samsung&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">productMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">103</span><span class="token punctuation">,</span> <span class="token string">&quot;Huawei&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 遍历时 key 是按顺序排序的（101, 102, 103）</span></span>
<span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> productMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; -&gt; &quot;</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、需要 &quot;范围查询&quot; 或 &quot;区间搜索&quot;</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> transactionMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">transactionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1707052800000L</span><span class="token punctuation">,</span> <span class="token string">&quot;订单 A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2024-02-05 00:00:00</span></span>
<span class="line">transactionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1707139200000L</span><span class="token punctuation">,</span> <span class="token string">&quot;订单 B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2024-02-06 00:00:00</span></span>
<span class="line">transactionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1707225600000L</span><span class="token punctuation">,</span> <span class="token string">&quot;订单 C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2024-02-07 00:00:00</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 获取 2 月 5 日到 2 月 6 日之间的交易</span></span>
<span class="line"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> transactionMap<span class="token punctuation">.</span><span class="token function">subMap</span><span class="token punctuation">(</span><span class="token number">1707052800000L</span><span class="token punctuation">,</span> <span class="token number">1707139200000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、相关类对比" tabindex="-1"><a class="header-anchor" href="#_2、相关类对比"><span>2、相关类对比</span></a></h3><table><thead><tr><th><strong>对比项</strong></th><th><strong>TreeMap</strong></th><th><strong>ConcurrentSkipListMap</strong></th></tr></thead><tbody><tr><td><strong>底层数据结构</strong></td><td>红黑树（Red-Black Tree）</td><td>跳表（Skip List）</td></tr><tr><td><strong>key 是否有序</strong></td><td>✅ 有序（按 key 排序）</td><td>✅ 有序（按 key 排序）</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(log n)</td><td>O(log n)</td></tr><tr><td><strong>是否允许 null key</strong></td><td>❌ 不允许</td><td>❌ 不允许</td></tr><tr><td><strong>是否允许 null value</strong></td><td>✅ 允许</td><td>✅ 允许</td></tr><tr><td><strong>线程安全</strong></td><td>❌ 非线程安全</td><td>✅ 线程安全</td></tr><tr><td><strong>适用场景</strong></td><td>需要排序、范围查询、导航结构</td><td>并发环境下的有序映射</td></tr><tr><td><strong>主要应用</strong></td><td>排名、日志存储、区间查找</td><td>线程安全的排序映射结构</td></tr></tbody></table><h2 id="四、hashmap和hashtable对比" tabindex="-1"><a class="header-anchor" href="#四、hashmap和hashtable对比"><span>四、HashMap和HashTable对比</span></a></h2><h3 id="_1、经典对比" tabindex="-1"><a class="header-anchor" href="#_1、经典对比"><span>1、经典对比</span></a></h3><table><thead><tr><th>对比项</th><th>HashMap</th><th>Hashtable</th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>❌ 非线程安全</td><td>✅ 线程安全（方法加锁 synchronized）</td></tr><tr><td><strong>性能</strong></td><td>🚀 性能更高（无锁）</td><td>🐌 性能较低（加锁导致开销大）</td></tr><tr><td><strong>是否允许 null</strong></td><td>✅ null key/value 允许</td><td>❌ null key/value 不允许</td></tr><tr><td><strong>数据结构</strong></td><td>JDK 1.8+: 数组 + 链表/红黑树</td><td>数组 + 链表</td></tr><tr><td><strong>默认初始容量</strong></td><td>16</td><td>11</td></tr><tr><td><strong>扩容方式</strong></td><td>容量翻倍（2^n 结构优化）</td><td>容量翻倍 + 1</td></tr><tr><td><strong>遍历方式</strong></td><td>迭代器 Iterator（fail-fast 机制）</td><td>Enumeration（旧版方式）</td></tr><tr><td><strong>适用场景</strong></td><td>适用于 单线程、高性能场景</td><td>适用于 历史遗留代码、并发场景（已被淘汰）</td></tr></tbody></table><h3 id="_2、推荐-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_2、推荐-concurrenthashmap"><span>2、推荐 ConcurrentHashMap</span></a></h3><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>✅ 用 HashMap</p><ul><li>大多数场景 推荐使用 HashMap，只在单线程环境下使用。</li></ul><p>✅ 用 ConcurrentHashMap（代替 Hashtable）</p><ul><li>如果需要线程安全，<strong>请用 ConcurrentHashMap，不要用 Hashtable！</strong></li><li>ConcurrentHashMap 在 <strong>高并发 场景下比 Hashtable 性能更优（局部加锁，甚至无锁）</strong>。</li></ul></div><h2 id="五、java-泛型" tabindex="-1"><a class="header-anchor" href="#五、java-泛型"><span>五、Java 泛型</span></a></h2>`,13)),s("p",null,[n[23]||(n[23]=a("常见问题，见：")),e(t,{to:"/interview/0_java#十四、说说你对泛型的理解"},{default:p(()=>n[22]||(n[22]=[a("Java总结-Java泛型")])),_:1})]),n[34]||(n[34]=l(`<h3 id="补充-类型擦除" tabindex="-1"><a class="header-anchor" href="#补充-类型擦除"><span><strong>补充：类型擦除</strong></span></a></h3><p>Java 泛型是编译时的特性，在运行时，Java 会移除（擦除）泛型的类型信息，这称为 类型擦除（Type Erasure）。</p><p><strong>原因</strong>： Java 的泛型是为了<strong>向后兼容</strong>（Generics 是 JDK 1.5 引入的，而 Java 需要兼容早期版本）。 <strong>JVM 并不支持真正的泛型</strong>，所有泛型信息在编译阶段就被擦除，JVM 看到的只有原始类型（Raw Type）。</p><p><strong>示例（泛型擦除前 vs. 擦除后）：</strong></p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 泛型代码</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">T</span> value<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> value<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>编译后（擦除后的字节码）：</strong></p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 擦除泛型后的代码</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Box</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 泛型 T 变成 Object</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">Object</span> value<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> value<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="六、线程的创建-thread-vs-runnable" tabindex="-1"><a class="header-anchor" href="#六、线程的创建-thread-vs-runnable"><span>六、线程的创建（Thread vs Runnable）</span></a></h2><h3 id="_1、继承-thread-类" tabindex="-1"><a class="header-anchor" href="#_1、继承-thread-类"><span>1、继承 Thread 类</span></a></h3><p>这种方法需要创建一个自定义的线程类，继承 Thread 类，并重写 run() 方法。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: Hello from thread!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 启动线程</span></span>
<span class="line">        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>优点：简单直观，适合只有一个任务的情况。</li><li>缺点：如果需要继承其他类，无法再继承 Thread 类（Java 是单继承）。</li></ul><h3 id="_2、实现-runnable-接口" tabindex="-1"><a class="header-anchor" href="#_2、实现-runnable-接口"><span>2、实现 Runnable 接口</span></a></h3><p>这种方法更灵活，创建一个实现 Runnable 接口的类，并将其作为参数传递给 Thread 构造函数。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: Hello from Runnable!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">MyRunnable</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将任务传递给线程</span></span>
<span class="line">        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 启动线程</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>优点：允许实现多个接口，提供更多的灵活性和可扩展性。</li><li>缺点：比继承 Thread 类稍微复杂一些，但通常更加推荐。</li></ul><h2 id="七、volatile-关键字" tabindex="-1"><a class="header-anchor" href="#七、volatile-关键字"><span>七、volatile 关键字</span></a></h2><h3 id="_1、线程可见性" tabindex="-1"><a class="header-anchor" href="#_1、线程可见性"><span>1、线程可见性</span></a></h3><h3 id="_2、防止指令重排" tabindex="-1"><a class="header-anchor" href="#_2、防止指令重排"><span>2、防止指令重排</span></a></h3><h2 id="八、wait-notify-notifyall" tabindex="-1"><a class="header-anchor" href="#八、wait-notify-notifyall"><span>八、wait() / notify() / notifyAll()</span></a></h2><h2 id="九、线程池基础-executors" tabindex="-1"><a class="header-anchor" href="#九、线程池基础-executors"><span>九、线程池基础（Executors）</span></a></h2><h3 id="_1、executors工具类" tabindex="-1"><a class="header-anchor" href="#_1、executors工具类"><span>1、Executors工具类</span></a></h3><p><code>Executors</code> 是 Java 中用于管理线程池的一个工具类，它是 <code>java.util.concurrent</code> 包的一部分。通过 <code>Executors</code>， 我们可以轻松地创建和管理线程池，避免手动管理线程的创建和销毁，提高程序的性能和可维护性。</p><h3 id="_2、-executors-的创建方式" tabindex="-1"><a class="header-anchor" href="#_2、-executors-的创建方式"><span>2、 <code>Executors</code> 的创建方式</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">//创建一个固定大小的线程池，该线程池可以容纳固定数量的线程。它适用于负载较为稳定的场景，线程数固定。</span></span>
<span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//创建一个可缓存的线程池。该线程池会根据需要创建新线程，如果某个线程长时间没有被使用，它会被回收。</span></span>
<span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//创建一个单线程的线程池，所有任务会按照提交的顺序依次执行。</span></span>
<span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//创建一个定时任务线程池，支持任务的延迟执行和定期执行。</span></span>
<span class="line"><span class="token class-name">ScheduledExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//创建一个工作窃取线程池，线程池会自动调整线程的数量，适用于有多个任务需要并发执行的场景。</span></span>
<span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newWorkStealingPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、-invokeall-和-invokeany" tabindex="-1"><a class="header-anchor" href="#_3、-invokeall-和-invokeany"><span>3、 <code>invokeAll()</code> 和 <code>invokeAny()</code></span></a></h3><p>这两个方法用于执行任务：</p><ul><li><p><strong><code>invokeAll()</code></strong>：将一组任务提交给线程池并等待所有任务执行完成。返回一个 <code>List&lt;Future&gt;</code>，表示每个任务的执行结果。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">tasks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">tasks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> results <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">invokeAll</span><span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong><code>invokeAny()</code></strong>：将一组任务提交给线程池，并等待其中任意一个任务完成。返回第一个完成任务的结果。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">Integer</span> result <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">invokeAny</span><span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h3 id="_4、使用-future-和-callable" tabindex="-1"><a class="header-anchor" href="#_4、使用-future-和-callable"><span>4、使用 <code>Future</code> 和 <code>Callable</code></span></a></h3><p>当需要获取任务执行结果时，通常会使用 <code>Future</code> 和 <code>Callable</code>：</p><ul><li><strong><code>Future</code></strong>：表示一个异步计算的结果，可以通过 <code>get()</code> 方法获取任务执行结果。</li><li><strong><code>Callable</code></strong>：类似于 <code>Runnable</code>，但是可以返回结果，并且可以抛出异常。</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 执行任务</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Integer</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取任务执行结果</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5、executors-总结" tabindex="-1"><a class="header-anchor" href="#_5、executors-总结"><span>5、Executors 总结</span></a></h3><p><code>Executors</code> 类提供了多种类型的线程池，可以根据任务的需求选择不同类型的线程池。合理使用线程池可以提高并发程序的性能， 并且避免了手动管理线程的复杂性，避免了线程创建和销毁的开销。</p><h3 id="_6、为何不建议使用-executors" tabindex="-1"><a class="header-anchor" href="#_6、为何不建议使用-executors"><span>6、为何不建议使用 Executors？</span></a></h3><p><strong>Executors</strong> 返回的线程池对象的弊端如下:</p><ul><li><p><strong>FixedThreadPool</strong> 和 <strong>SingleThreadPool</strong>: 允许的请求队列（<strong>LinkedBlockingQueue</strong>）长度为 <strong>Integer.MAX VALUE</strong>，可能会堆积大量的请求，从而导致 OOM。</p></li><li><p><strong>CachedThreadPool</strong>: 允许的创建线程数量为 <strong>LinkedBlockingQueue</strong>，可能会创建大量的线程，从而导致 OOM。</p></li></ul>`,37)),s("p",null,[n[25]||(n[25]=a("综上，为了手动控制线程池，建议自己使用 ")),e(t,{to:"/currency/1_threadpool"},{default:p(()=>n[24]||(n[24]=[a("ThreadPoolExecutor")])),_:1}),n[26]||(n[26]=a(" 来创建线程池"))]),n[35]||(n[35]=l('<h2 id="十、threadlocal" tabindex="-1"><a class="header-anchor" href="#十、threadlocal"><span>十、ThreadLocal</span></a></h2><h3 id="_1、基础原理" tabindex="-1"><a class="header-anchor" href="#_1、基础原理"><span>1、基础原理</span></a></h3><p>ThreadLocal 是 Java 提供的一个类，用于为<strong>每个线程提供独立的变量副本</strong>。每个线程访问自己的副本，不会与其他线程共享数据，常用于处理线程安全的问题。</p><ul><li>业务使用示意图</li></ul><p><img src="'+h+'" alt="img_5.png"></p><ul><li>内部结构示意图：</li></ul><p><img src="'+v+'" alt="img_5.png"></p><h3 id="_2、应用场景" tabindex="-1"><a class="header-anchor" href="#_2、应用场景"><span>2、应用场景</span></a></h3><ul><li><strong>数据库连接</strong>：如低代码系统中的数据源管理；</li></ul><p>为每个线程提供独立的数据库连接或事务对象，避免多个线程同时操作同一个连接，提升性能和安全性。</p><ul><li><strong>用户会话信息</strong>：如单体服务的用户会话信息管理；</li></ul><p>在 Web 应用中，可以使用 ThreadLocal 存储每个请求的用户会话信息，使每个线程能够独立地访问相关的会话数据。</p>',12))])}const f=o(m,[["render",g],["__file","1_base.html.vue"]]),x=JSON.parse('{"path":"/java/1_base.html","title":"Java基础","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、Hashmap分析","slug":"一、hashmap分析","link":"#一、hashmap分析","children":[{"level":3,"title":"1、 哈希表（Hash Table）","slug":"_1、-哈希表-hash-table","link":"#_1、-哈希表-hash-table","children":[]},{"level":3,"title":"2、 哈希冲突","slug":"_2、-哈希冲突","link":"#_2、-哈希冲突","children":[]},{"level":3,"title":"3、  扩容机制","slug":"_3、-扩容机制","link":"#_3、-扩容机制","children":[]},{"level":3,"title":"4、 时间复杂度","slug":"_4、-时间复杂度","link":"#_4、-时间复杂度","children":[]},{"level":3,"title":"5、 关键特点","slug":"_5、-关键特点","link":"#_5、-关键特点","children":[]}]},{"level":2,"title":"二、LinkedHashMap分析","slug":"二、linkedhashmap分析","link":"#二、linkedhashmap分析","children":[{"level":3,"title":"1、类继承关系","slug":"_1、类继承关系","link":"#_1、类继承关系","children":[]},{"level":3,"title":"2、基本原理","slug":"_2、基本原理","link":"#_2、基本原理","children":[]}]},{"level":2,"title":"三、ConcurrentHashMap分析","slug":"三、concurrenthashmap分析","link":"#三、concurrenthashmap分析","children":[{"level":3,"title":"1、ConcurrentHashMap基本特性","slug":"_1、concurrenthashmap基本特性","link":"#_1、concurrenthashmap基本特性","children":[]},{"level":3,"title":"2、JDK 1.7 和 1.8 的区别","slug":"_2、jdk-1-7-和-1-8-的区别","link":"#_2、jdk-1-7-和-1-8-的区别","children":[]}]},{"level":2,"title":"四、ConcurrentHashMap为什么放弃分段锁？","slug":"四、concurrenthashmap为什么放弃分段锁","link":"#四、concurrenthashmap为什么放弃分段锁","children":[{"level":3,"title":"1、 JDK 1.7 前分段锁的弊端","slug":"_1、-jdk-1-7-前分段锁的弊端","link":"#_1、-jdk-1-7-前分段锁的弊端","children":[]},{"level":3,"title":"2、 JDK 1.8 后新方案","slug":"_2、-jdk-1-8-后新方案","link":"#_2、-jdk-1-8-后新方案","children":[]}]},{"level":2,"title":"四、HashMap、LinkedHashMap、ConcurrentHashMap对比","slug":"四、hashmap、linkedhashmap、concurrenthashmap对比","link":"#四、hashmap、linkedhashmap、concurrenthashmap对比","children":[]},{"level":2,"title":"三、TreeMap分析","slug":"三、treemap分析","link":"#三、treemap分析","children":[{"level":3,"title":"1、源码分析","slug":"_1、源码分析","link":"#_1、源码分析","children":[]},{"level":3,"title":"2、相关类对比","slug":"_2、相关类对比","link":"#_2、相关类对比","children":[]}]},{"level":2,"title":"四、HashMap和HashTable对比","slug":"四、hashmap和hashtable对比","link":"#四、hashmap和hashtable对比","children":[{"level":3,"title":"1、经典对比","slug":"_1、经典对比","link":"#_1、经典对比","children":[]},{"level":3,"title":"2、推荐 ConcurrentHashMap","slug":"_2、推荐-concurrenthashmap","link":"#_2、推荐-concurrenthashmap","children":[]}]},{"level":2,"title":"五、Java 泛型","slug":"五、java-泛型","link":"#五、java-泛型","children":[{"level":3,"title":"补充：类型擦除","slug":"补充-类型擦除","link":"#补充-类型擦除","children":[]}]},{"level":2,"title":"六、线程的创建（Thread vs Runnable）","slug":"六、线程的创建-thread-vs-runnable","link":"#六、线程的创建-thread-vs-runnable","children":[{"level":3,"title":"1、继承 Thread 类","slug":"_1、继承-thread-类","link":"#_1、继承-thread-类","children":[]},{"level":3,"title":"2、实现 Runnable 接口","slug":"_2、实现-runnable-接口","link":"#_2、实现-runnable-接口","children":[]}]},{"level":2,"title":"七、volatile 关键字","slug":"七、volatile-关键字","link":"#七、volatile-关键字","children":[{"level":3,"title":"1、线程可见性","slug":"_1、线程可见性","link":"#_1、线程可见性","children":[]},{"level":3,"title":"2、防止指令重排","slug":"_2、防止指令重排","link":"#_2、防止指令重排","children":[]}]},{"level":2,"title":"八、wait() / notify() / notifyAll()","slug":"八、wait-notify-notifyall","link":"#八、wait-notify-notifyall","children":[]},{"level":2,"title":"九、线程池基础（Executors）","slug":"九、线程池基础-executors","link":"#九、线程池基础-executors","children":[{"level":3,"title":"1、Executors工具类","slug":"_1、executors工具类","link":"#_1、executors工具类","children":[]},{"level":3,"title":"2、 Executors 的创建方式","slug":"_2、-executors-的创建方式","link":"#_2、-executors-的创建方式","children":[]},{"level":3,"title":"3、 invokeAll() 和 invokeAny()","slug":"_3、-invokeall-和-invokeany","link":"#_3、-invokeall-和-invokeany","children":[]},{"level":3,"title":"4、使用 Future 和 Callable","slug":"_4、使用-future-和-callable","link":"#_4、使用-future-和-callable","children":[]},{"level":3,"title":"5、Executors 总结","slug":"_5、executors-总结","link":"#_5、executors-总结","children":[]},{"level":3,"title":"6、为何不建议使用 Executors？","slug":"_6、为何不建议使用-executors","link":"#_6、为何不建议使用-executors","children":[]}]},{"level":2,"title":"十、ThreadLocal","slug":"十、threadlocal","link":"#十、threadlocal","children":[{"level":3,"title":"1、基础原理","slug":"_1、基础原理","link":"#_1、基础原理","children":[]},{"level":3,"title":"2、应用场景","slug":"_2、应用场景","link":"#_2、应用场景","children":[]}]}],"git":{"updatedTime":1742735410000,"contributors":[{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":9,"url":"https://github.com/Clarence"},{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":10,"url":"https://github.com/hanchen"}]},"filePathRelative":"java/1_base.md"}');export{f as comp,x as data};
