import{_ as o,c as r,b as p,d as e,e as l,f as s,a,r as i,o as c}from"./app-CGOuCsDt.js";const d="/clarence-doc/assets/hashmap_hash_conflict-RhDZVAr2.png",u="/clarence-doc/assets/LinkedHashMap-uNfJhtFw.png",h="/clarence-doc/assets/TreeMap-RKRumpct.png",k={};function g(m,n){const t=i("RouteLink");return c(),r("div",null,[n[22]||(n[22]=p('<h1 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础"><span>Java基础</span></a></h1><h2 id="一、hashmap分析" tabindex="-1"><a class="header-anchor" href="#一、hashmap分析"><span>一、Hashmap分析</span></a></h2><p>HashMap 是一种基于哈希表的数据结构，它实现了 Map 接口，用于存储键值对 (key-value)。其基本原理如下：</p><h3 id="_1、-哈希表-hash-table" tabindex="-1"><a class="header-anchor" href="#_1、-哈希表-hash-table"><span>1、 哈希表（Hash Table）</span></a></h3><p>HashMap 是基于哈希表实现的，哈希表的基本思想是通过将数据的键值对映射到一个数组的索引位置上来提高数据查找的效率。具体流程如下：</p><ul><li>哈希函数：</li></ul><p>HashMap 使用哈希函数将键（key）映射到数组的索引位置。哈希函数的目的是通过计算一个值，将不同的键映射到哈希表中的位置。</p><ul><li>数组：</li></ul><p>哈希表内部使用一个数组来存储数据。数组中的每个元素存储一个链表（或者在 Java 8 后是</p>',9)),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:l(()=>n[0]||(n[0]=[s("红黑树")])),_:1}),n[23]||(n[23]=s("），用于处理哈希冲突。")),n[24]||(n[24]=a("h3",{id:"_2、-哈希冲突",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_2、-哈希冲突"},[a("span",null,"2、 哈希冲突")])],-1)),n[25]||(n[25]=a("p",null,"由于哈希函数不可能做到完全唯一的映射，不同的键可能会被映射到相同的索引，这种情况称为哈希冲突。HashMap 通过以下方式解决哈希冲突：",-1)),a("ul",null,[n[6]||(n[6]=a("li",null,[a("p",null,"链表法（链式哈希）：")],-1)),a("li",null,[a("p",null,[n[2]||(n[2]=s("在发生冲突的情况下，HashMap 会将冲突的键值对存储到一个链表中 （或者 ")),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:l(()=>n[1]||(n[1]=[s("红黑树")])),_:1}),n[3]||(n[3]=s("）。 当多个元素映射到同一个索引位置时，它们会形成一个链表。"))])]),a("li",null,[e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:l(()=>n[4]||(n[4]=[s("红黑树")])),_:1}),n[5]||(n[5]=s("法："))])]),n[26]||(n[26]=a("p",null,"在 Java 8 及以后的版本中，如果链表的长度超过一定阈值（默认为 8），HashMap 会将链表转化为",-1)),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:l(()=>n[7]||(n[7]=[s("红黑树")])),_:1}),n[27]||(n[27]=p('，以提高查询效率。<p><img src="'+d+'" alt="img.png"></p><h3 id="_3、-扩容机制" tabindex="-1"><a class="header-anchor" href="#_3、-扩容机制"><span>3、 扩容机制</span></a></h3><p>当 HashMap 中的元素过多时，哈希表的负载因子（load factor）可能会达到阈值，导致哈希表的存储效率降低。默认情况下，负载因子为 0.75。<strong>当元素个数超过当前容量 * 负载因子时，HashMap 会进行扩容</strong>（通常是原数组大小的 2 倍）。</p><p>扩容过程中，所有元素的哈希值会被重新计算，并重新放置到新的数组位置。这是因为<strong>哈希表的大小发生变化，导致原先的索引位置不再适用</strong>。</p><h3 id="_4、-时间复杂度" tabindex="-1"><a class="header-anchor" href="#_4、-时间复杂度"><span>4、 时间复杂度</span></a></h3><ul><li>查找、插入、删除操作的时间复杂度：</li></ul>',7)),a("p",null,[n[9]||(n[9]=s("在理想情况下，哈希表的查找、插入和删除操作的时间复杂度为 O(1)。但是，如果发生哈希冲突，性能会退化到 O(n)（链表长度为 n 时）。使用 ")),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:l(()=>n[8]||(n[8]=[s("红黑树")])),_:1}),n[10]||(n[10]=s("优化后，最坏情况下时间复杂度为 O(log n)。"))]),n[28]||(n[28]=p('<ul><li>扩容操作的时间复杂度：</li></ul><p>扩容是一个相对耗时的操作，时间复杂度为 O(n)，但扩容操作是按需进行的，不是频繁发生，因此平均而言，HashMap 的操作仍然是 O(1)。</p><h3 id="_5、-关键特点" tabindex="-1"><a class="header-anchor" href="#_5、-关键特点"><span>5、 关键特点</span></a></h3><ul><li>非线程安全：HashMap 不是线程安全的，如果在多线程环境下使用，需要考虑同步问题。</li><li>允许 null 键和 null 值：HashMap 允许一个 null 键和多个 null 值。</li><li>元素顺序不保证：HashMap 不保证键值对的顺序，因为它是基于哈希函数计算索引的，顺序是无序的。如果需要顺序，可以使用 LinkedHashMap</li></ul><h2 id="二、linkedhashmap分析" tabindex="-1"><a class="header-anchor" href="#二、linkedhashmap分析"><span>二、LinkedHashMap分析</span></a></h2><ul><li>类关联图如下所示</li></ul><p><img src="'+u+`" alt=""></p><h2 id="三、concurrenthashmap分析" tabindex="-1"><a class="header-anchor" href="#三、concurrenthashmap分析"><span>三、ConcurrentHashMap分析</span></a></h2><ul><li>ConcurrentHashMap基本特性：</li></ul><table><thead><tr><th><strong>特性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>采用 CAS + 自旋锁 替代 synchronized，减少锁竞争</td></tr><tr><td><strong>高并发</strong></td><td>读操作无锁，写操作局部加锁，避免全局锁的性能瓶颈</td></tr><tr><td><strong>不支持 null</strong></td><td>key 和 value 都 不能为 null，防止 NullPointerException</td></tr><tr><td><strong>比 Hashtable 性能高</strong></td><td>Hashtable 使用 synchronized 进行全表加锁，而 ConcurrentHashMap 采用 分段锁机制（JDK 1.7）和 CAS + 自旋锁（JDK 1.8）</td></tr></tbody></table><ul><li>在 JDK 1.7 和 1.8 的区别</li></ul><table><thead><tr><th><strong>版本</strong></th><th><strong>JDK 1.7</strong></th><th><strong>JDK 1.8 及以后</strong></th></tr></thead><tbody><tr><td><strong>底层数据结构</strong></td><td>Segment（分段锁） + 数组 + 链表</td><td>数组 + 链表 + 红黑树（大于 8 个元素）</td></tr><tr><td><strong>加锁方式</strong></td><td>分段锁（Segment 继承 ReentrantLock）</td><td>CAS + 自旋锁 + synchronized（局部）</td></tr><tr><td><strong>并发控制</strong></td><td>多个 Segment 互不影响</td><td>CAS 方式优化，减少锁竞争</td></tr><tr><td><strong>写入性能</strong></td><td>分段锁，性能较好</td><td>CAS + 局部锁，性能更高</td></tr><tr><td><strong>扩容机制</strong></td><td>Segment 级别扩容</td><td>无锁扩容，支持并发扩容</td></tr></tbody></table><ul><li>更多细节，如基本结构，及其方法，研究后再写；</li></ul><h2 id="四、concurrenthashmap为什么放弃分段锁" tabindex="-1"><a class="header-anchor" href="#四、concurrenthashmap为什么放弃分段锁"><span>四、ConcurrentHashMap为什么放弃分段锁？</span></a></h2><h3 id="_1、-分段锁的弊端" tabindex="-1"><a class="header-anchor" href="#_1、-分段锁的弊端"><span>1、 分段锁的弊端</span></a></h3><h4 id="🔴-1-1-扩容性能低" tabindex="-1"><a class="header-anchor" href="#🔴-1-1-扩容性能低"><span>🔴 1.1 扩容性能低</span></a></h4><p>JDK 1.7 ConcurrentHashMap 采用 <strong>分段锁（Segment）</strong>，每个 Segment 维护一个独立的 HashEntry[]，但在 扩容 时：</p><ul><li>需要 <strong>对整个 Segment 加锁</strong>，导致其他线程无法访问该 Segment，影响并发性能。</li><li><strong>迁移数据需要同步整个 Segment</strong>，多个线程不能同时进行数据迁移。</li></ul><h4 id="🔴-1-2-空间浪费" tabindex="-1"><a class="header-anchor" href="#🔴-1-2-空间浪费"><span>🔴 1.2 空间浪费</span></a></h4><ul><li>ConcurrentHashMap 预先分配多个 Segment，即使有的 Segment 为空，仍然占用内存，导致 空间利用率低。</li></ul><h4 id="🔴-1-3-结构复杂-代码难维护" tabindex="-1"><a class="header-anchor" href="#🔴-1-3-结构复杂-代码难维护"><span>🔴 1.3 结构复杂，代码难维护</span></a></h4><ul><li>Segment <strong>继承 ReentrantLock，导致 锁管理复杂</strong>，增加了不必要的开销。</li><li>Segment 结构导致 put 操作需要 <strong>两次 hash 计算</strong>（一次计算 Segment 索引，一次计算 Entry 索引），影响性能：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"> <span class="token comment">// 找到 Segment</span></span>
<span class="line"><span class="token keyword">int</span> segmentIndex <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&gt;&gt;&gt;</span> segmentShift<span class="token punctuation">)</span> <span class="token operator">&amp;</span> segmentMask<span class="token punctuation">;</span></span>
<span class="line"><span class="token comment">// 在该 Segment 内部查找</span></span>
<span class="line"><span class="token keyword">int</span> bucketIndex <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>segment<span class="token punctuation">.</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、-jdk-1-8-后新方案" tabindex="-1"><a class="header-anchor" href="#_2、-jdk-1-8-后新方案"><span>2、 JDK 1.8 后新方案</span></a></h3><p>JDK 1.8 直接去掉 Segment，采用 <strong>数组 + 链表 + 红黑树</strong> 结构，结合 CAS + synchronized 局部锁，实现更高效的并发控制：</p><h4 id="✅-2-1-采用-cas-无锁优化" tabindex="-1"><a class="header-anchor" href="#✅-2-1-采用-cas-无锁优化"><span>✅ 2.1 采用 CAS 无锁优化</span></a></h4><ul><li>CAS（Compare And Swap） 是一种 乐观锁，当多个线程竞争同一个 Node 插入时，采用 CAS 方式写入，避免不必要的锁竞争：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这样，当 Node 为空时，线程可以 <strong>无锁写入</strong>，提高吞吐量。</li></ul><h4 id="✅-2-2-采用-synchronized-代替-reentrantlock" tabindex="-1"><a class="header-anchor" href="#✅-2-2-采用-synchronized-代替-reentrantlock"><span>✅ 2.2 采用 synchronized 代替 ReentrantLock</span></a></h4><ul><li>由于 synchronized 在 JDK 1.8 中已优化（锁粗化、锁消除、偏向锁等），其性能接近 ReentrantLock，因此 JDK 1.8 直接使用 synchronized 进行局部加锁：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// f 是桶中的第一个节点</span></span>
<span class="line"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token function">putValUnderLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>只锁定当前桶位（Node[] 数组中的一个索引），避免对整个 Map 加锁，减少竞争。</li></ul><h4 id="✅-2-3-红黑树优化-提升查询性能" tabindex="-1"><a class="header-anchor" href="#✅-2-3-红黑树优化-提升查询性能"><span>✅ 2.3 红黑树优化，提升查询性能</span></a></h4><ul><li>如果某个桶的链表长度 超过 8，则转换为 红黑树，提升查询效率：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>链表查询 O(n) → 红黑树查询 O(log n)，减少链表查找的性能损耗。</li></ul><h4 id="✅-2-4-支持无锁扩容" tabindex="-1"><a class="header-anchor" href="#✅-2-4-支持无锁扩容"><span>✅ 2.4 支持无锁扩容</span></a></h4><ul><li>多个线程可以并发迁移数据，提升扩容效率，避免 Segment 级别的全局锁：</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>sizeCtl <span class="token operator">&lt;</span> table<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">0.75</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token function">transferNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 进行无锁扩容</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>采用 <strong>分批次迁移</strong>，多个线程 并行扩容，减少停顿时间。</li></ul><h2 id="四、hashmap、linkedhashmap、concurrenthashmap分析" tabindex="-1"><a class="header-anchor" href="#四、hashmap、linkedhashmap、concurrenthashmap分析"><span>四、HashMap、LinkedHashMap、ConcurrentHashMap分析</span></a></h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>HashMap</strong></th><th><strong>LinkedHashMap</strong></th><th><strong>ConcurrentHashMap</strong></th></tr></thead><tbody><tr><td><strong>底层数据结构</strong></td><td>哈希表（数组 + 链表/红黑树）</td><td>哈希表 + 双向链表</td><td>哈希表（分段锁、CAS 机制）</td></tr><tr><td><strong>key 是否有序</strong></td><td>❌ 无序</td><td>✅ 按插入顺序排序</td><td>❌ 无序</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(1) 平均，O(n) 最坏</td><td>O(1) 平均，O(n) 最坏</td><td>O(1) 平均，O(n) 最坏</td></tr><tr><td><strong>是否允许 null key</strong></td><td>✅ 允许</td><td>✅ 允许</td><td>❌ 不允许</td></tr><tr><td><strong>是否允许 null value</strong></td><td>✅ 允许</td><td>✅ 允许</td><td>❌ 不允许</td></tr><tr><td><strong>线程安全</strong></td><td>❌ 非线程安全</td><td>❌ 非线程安全</td><td>✅ 线程安全</td></tr><tr><td><strong>适用场景</strong></td><td>快速查找、无序存储、大量数据</td><td>需要按插入顺序遍历的场景</td><td>并发环境下的高效哈希映射</td></tr><tr><td><strong>主要应用</strong></td><td>缓存、映射查找、对象存储</td><td>LRU 缓存、访问顺序存储</td><td>高并发场景，如缓存、线程池</td></tr></tbody></table><h2 id="三、treemap分析" tabindex="-1"><a class="header-anchor" href="#三、treemap分析"><span>三、TreeMap分析</span></a></h2><h3 id="_1、源码分析" tabindex="-1"><a class="header-anchor" href="#_1、源码分析"><span>1、源码分析</span></a></h3><ul><li>类关联图如下所示：</li></ul><p><img src="`+h+'" alt="image.png"></p><ul><li>TreeMap 的核心特点</li></ul>',48)),a("table",null,[n[19]||(n[19]=a("thead",null,[a("tr",null,[a("th",null,"特性"),a("th",null,"说明")])],-1)),a("tbody",null,[a("tr",null,[n[13]||(n[13]=a("td",null,"底层实现",-1)),a("td",null,[e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:l(()=>n[11]||(n[11]=[s("红黑树")])),_:1}),n[12]||(n[12]=s("（Red-Black Tree），是一种自平衡二叉搜索树（BST）"))])]),n[14]||(n[14]=a("tr",null,[a("td",null,"排序方式"),a("td",null,"默认按 key 的 自然顺序（Comparable） 排序，也可以传入 自定义 Comparator")],-1)),n[15]||(n[15]=a("tr",null,[a("td",null,"时间复杂度"),a("td",null,"O(log n)（增、删、查）")],-1)),n[16]||(n[16]=a("tr",null,[a("td",null,"是否允许 null key"),a("td",null,"❌ 不允许 null key（会抛 NullPointerException）")],-1)),n[17]||(n[17]=a("tr",null,[a("td",null,"是否允许 null value"),a("td",null,"✅ 允许 null value")],-1)),n[18]||(n[18]=a("tr",null,[a("td",null,"是否线程安全"),a("td",null,"❌ 非线程安全（需要 Collections.synchronizedMap() 保护）")],-1))])]),n[29]||(n[29]=p(`<div class="hint-container important"><p class="hint-container-title">使用途径</p><p>适用于需要 &quot;<strong>自动排序</strong>&quot; 和 &quot;<strong>范围查询</strong>&quot; 的场景。</p></div><p>1、适用场景：数据存储时要求按照 key 进行排序，方便后续查询和展示</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> productMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">productMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">102</span><span class="token punctuation">,</span> <span class="token string">&quot;iPhone&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">productMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token string">&quot;Samsung&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">productMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">103</span><span class="token punctuation">,</span> <span class="token string">&quot;Huawei&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 遍历时 key 是按顺序排序的（101, 102, 103）</span></span>
<span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> productMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; -&gt; &quot;</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、需要 &quot;范围查询&quot; 或 &quot;区间搜索&quot;</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> transactionMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">transactionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1707052800000L</span><span class="token punctuation">,</span> <span class="token string">&quot;订单 A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2024-02-05 00:00:00</span></span>
<span class="line">transactionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1707139200000L</span><span class="token punctuation">,</span> <span class="token string">&quot;订单 B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2024-02-06 00:00:00</span></span>
<span class="line">transactionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1707225600000L</span><span class="token punctuation">,</span> <span class="token string">&quot;订单 C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2024-02-07 00:00:00</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 获取 2 月 5 日到 2 月 6 日之间的交易</span></span>
<span class="line"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> transactionMap<span class="token punctuation">.</span><span class="token function">subMap</span><span class="token punctuation">(</span><span class="token number">1707052800000L</span><span class="token punctuation">,</span> <span class="token number">1707139200000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、相关类对比" tabindex="-1"><a class="header-anchor" href="#_2、相关类对比"><span>2、相关类对比</span></a></h3><table><thead><tr><th><strong>对比项</strong></th><th><strong>TreeMap</strong></th><th><strong>ConcurrentSkipListMap</strong></th></tr></thead><tbody><tr><td><strong>底层数据结构</strong></td><td>红黑树（Red-Black Tree）</td><td>跳表（Skip List）</td></tr><tr><td><strong>key 是否有序</strong></td><td>✅ 有序（按 key 排序）</td><td>✅ 有序（按 key 排序）</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(log n)</td><td>O(log n)</td></tr><tr><td><strong>是否允许 null key</strong></td><td>❌ 不允许</td><td>❌ 不允许</td></tr><tr><td><strong>是否允许 null value</strong></td><td>✅ 允许</td><td>✅ 允许</td></tr><tr><td><strong>线程安全</strong></td><td>❌ 非线程安全</td><td>✅ 线程安全</td></tr><tr><td><strong>适用场景</strong></td><td>需要排序、范围查询、导航结构</td><td>并发环境下的有序映射</td></tr><tr><td><strong>主要应用</strong></td><td>排名、日志存储、区间查找</td><td>线程安全的排序映射结构</td></tr></tbody></table><h2 id="四、hashmap和hashtable的区别" tabindex="-1"><a class="header-anchor" href="#四、hashmap和hashtable的区别"><span>四、HashMap和HashTable的区别</span></a></h2><table><thead><tr><th>对比项</th><th>HashMap</th><th>Hashtable</th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>❌ 非线程安全</td><td>✅ 线程安全（方法加锁 synchronized）</td></tr><tr><td><strong>性能</strong></td><td>🚀 性能更高（无锁）</td><td>🐌 性能较低（加锁导致开销大）</td></tr><tr><td><strong>是否允许 null</strong></td><td>✅ null key/value 允许</td><td>❌ null key/value 不允许</td></tr><tr><td><strong>数据结构</strong></td><td>JDK 1.8+: 数组 + 链表/红黑树</td><td>数组 + 链表</td></tr><tr><td><strong>默认初始容量</strong></td><td>16</td><td>11</td></tr><tr><td><strong>扩容方式</strong></td><td>容量翻倍（2^n 结构优化）</td><td>容量翻倍 + 1</td></tr><tr><td><strong>遍历方式</strong></td><td>迭代器 Iterator（fail-fast 机制）</td><td>Enumeration（旧版方式）</td></tr><tr><td><strong>适用场景</strong></td><td>适用于 单线程、高性能场景</td><td>适用于 历史遗留代码、并发场景（已被淘汰）</td></tr></tbody></table><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>✅ 用 HashMap</p><ul><li>大多数场景 推荐使用 HashMap，只在单线程环境下使用。</li></ul><p>✅ 用 ConcurrentHashMap（代替 Hashtable）</p><ul><li>如果需要线程安全，<strong>请用 ConcurrentHashMap，不要用 Hashtable！</strong></li><li>ConcurrentHashMap 在 <strong>高并发 场景下比 Hashtable 性能更优（局部加锁，甚至无锁）</strong>。</li></ul></div><h2 id="六、java-泛型" tabindex="-1"><a class="header-anchor" href="#六、java-泛型"><span>六、Java 泛型</span></a></h2>`,11)),a("p",null,[n[21]||(n[21]=s("常见问题，见：")),e(t,{to:"/interview/0_java#六、java-泛型"},{default:l(()=>n[20]||(n[20]=[s("Java总结-Java泛型")])),_:1})]),n[30]||(n[30]=p('<h3 id="_1、泛型类与泛型方法" tabindex="-1"><a class="header-anchor" href="#_1、泛型类与泛型方法"><span>1、泛型类与泛型方法</span></a></h3><h3 id="_2、通配符-extends-t-vs-super-t" tabindex="-1"><a class="header-anchor" href="#_2、通配符-extends-t-vs-super-t"><span>2、通配符（? extends T vs ? super T）</span></a></h3><h3 id="_3、类型擦除" tabindex="-1"><a class="header-anchor" href="#_3、类型擦除"><span>3、类型擦除</span></a></h3><h2 id="lambda-表达式与函数式编程" tabindex="-1"><a class="header-anchor" href="#lambda-表达式与函数式编程"><span>Lambda 表达式与函数式编程</span></a></h2><h3 id="_1、lambda-语法" tabindex="-1"><a class="header-anchor" href="#_1、lambda-语法"><span>1、Lambda 语法</span></a></h3><h3 id="_2、functional-interface-函数式接口" tabindex="-1"><a class="header-anchor" href="#_2、functional-interface-函数式接口"><span>2、Functional Interface（函数式接口）</span></a></h3><h3 id="_3、方法引用-method-reference" tabindex="-1"><a class="header-anchor" href="#_3、方法引用-method-reference"><span>3、方法引用（Method Reference）</span></a></h3><h3 id="_4、stream-api-基础" tabindex="-1"><a class="header-anchor" href="#_4、stream-api-基础"><span>4、Stream API 基础</span></a></h3><h2 id="java-输入-输出-i-o-流" tabindex="-1"><a class="header-anchor" href="#java-输入-输出-i-o-流"><span>Java 输入/输出（I/O 流）</span></a></h2><h3 id="_1、字节流-inputstream-outputstream" tabindex="-1"><a class="header-anchor" href="#_1、字节流-inputstream-outputstream"><span>1、字节流（InputStream, OutputStream）</span></a></h3><h3 id="_2、字符流-reader-writer" tabindex="-1"><a class="header-anchor" href="#_2、字符流-reader-writer"><span>2、字符流（Reader, Writer）</span></a></h3><h3 id="_3、文件操作-file-类" tabindex="-1"><a class="header-anchor" href="#_3、文件操作-file-类"><span>3、文件操作（File 类）</span></a></h3><h3 id="_4、序列化与反序列化" tabindex="-1"><a class="header-anchor" href="#_4、序列化与反序列化"><span>4、序列化与反序列化</span></a></h3><h2 id="并发基础" tabindex="-1"><a class="header-anchor" href="#并发基础"><span>并发基础</span></a></h2><h3 id="_1、线程的创建-thread-vs-runnable" tabindex="-1"><a class="header-anchor" href="#_1、线程的创建-thread-vs-runnable"><span>1、线程的创建（Thread vs Runnable）</span></a></h3><h3 id="_2、synchronized-关键字-方法同步、代码块同步" tabindex="-1"><a class="header-anchor" href="#_2、synchronized-关键字-方法同步、代码块同步"><span>2、synchronized 关键字（方法同步、代码块同步）</span></a></h3><h3 id="_3、volatile-关键字" tabindex="-1"><a class="header-anchor" href="#_3、volatile-关键字"><span>3、volatile 关键字</span></a></h3><h3 id="_4、wait-notify-notifyall" tabindex="-1"><a class="header-anchor" href="#_4、wait-notify-notifyall"><span>4、wait() / notify() / notifyAll()</span></a></h3><h3 id="_5、线程池基础-executors-工具类" tabindex="-1"><a class="header-anchor" href="#_5、线程池基础-executors-工具类"><span>5、线程池基础（Executors 工具类）</span></a></h3><h3 id="_6、threadlocal" tabindex="-1"><a class="header-anchor" href="#_6、threadlocal"><span>6、ThreadLocal</span></a></h3><h4 id="_1、原理及其应用" tabindex="-1"><a class="header-anchor" href="#_1、原理及其应用"><span>1、原理及其应用</span></a></h4><h4 id="_2、transmittable-threadlocal" tabindex="-1"><a class="header-anchor" href="#_2、transmittable-threadlocal"><span>2、Transmittable ThreadLocal</span></a></h4>',22))])}const v=o(k,[["render",g],["__file","1_base.html.vue"]]),f=JSON.parse('{"path":"/java/1_base.html","title":"Java基础","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、Hashmap分析","slug":"一、hashmap分析","link":"#一、hashmap分析","children":[{"level":3,"title":"1、 哈希表（Hash Table）","slug":"_1、-哈希表-hash-table","link":"#_1、-哈希表-hash-table","children":[]},{"level":3,"title":"2、 哈希冲突","slug":"_2、-哈希冲突","link":"#_2、-哈希冲突","children":[]},{"level":3,"title":"3、  扩容机制","slug":"_3、-扩容机制","link":"#_3、-扩容机制","children":[]},{"level":3,"title":"4、 时间复杂度","slug":"_4、-时间复杂度","link":"#_4、-时间复杂度","children":[]},{"level":3,"title":"5、 关键特点","slug":"_5、-关键特点","link":"#_5、-关键特点","children":[]}]},{"level":2,"title":"二、LinkedHashMap分析","slug":"二、linkedhashmap分析","link":"#二、linkedhashmap分析","children":[]},{"level":2,"title":"三、ConcurrentHashMap分析","slug":"三、concurrenthashmap分析","link":"#三、concurrenthashmap分析","children":[]},{"level":2,"title":"四、ConcurrentHashMap为什么放弃分段锁？","slug":"四、concurrenthashmap为什么放弃分段锁","link":"#四、concurrenthashmap为什么放弃分段锁","children":[{"level":3,"title":"1、 分段锁的弊端","slug":"_1、-分段锁的弊端","link":"#_1、-分段锁的弊端","children":[]},{"level":3,"title":"2、 JDK 1.8 后新方案","slug":"_2、-jdk-1-8-后新方案","link":"#_2、-jdk-1-8-后新方案","children":[]}]},{"level":2,"title":"四、HashMap、LinkedHashMap、ConcurrentHashMap分析","slug":"四、hashmap、linkedhashmap、concurrenthashmap分析","link":"#四、hashmap、linkedhashmap、concurrenthashmap分析","children":[]},{"level":2,"title":"三、TreeMap分析","slug":"三、treemap分析","link":"#三、treemap分析","children":[{"level":3,"title":"1、源码分析","slug":"_1、源码分析","link":"#_1、源码分析","children":[]},{"level":3,"title":"2、相关类对比","slug":"_2、相关类对比","link":"#_2、相关类对比","children":[]}]},{"level":2,"title":"四、HashMap和HashTable的区别","slug":"四、hashmap和hashtable的区别","link":"#四、hashmap和hashtable的区别","children":[]},{"level":2,"title":"六、Java 泛型","slug":"六、java-泛型","link":"#六、java-泛型","children":[{"level":3,"title":"1、泛型类与泛型方法","slug":"_1、泛型类与泛型方法","link":"#_1、泛型类与泛型方法","children":[]},{"level":3,"title":"2、通配符（? extends T vs ? super T）","slug":"_2、通配符-extends-t-vs-super-t","link":"#_2、通配符-extends-t-vs-super-t","children":[]},{"level":3,"title":"3、类型擦除","slug":"_3、类型擦除","link":"#_3、类型擦除","children":[]}]},{"level":2,"title":"Lambda 表达式与函数式编程","slug":"lambda-表达式与函数式编程","link":"#lambda-表达式与函数式编程","children":[{"level":3,"title":"1、Lambda 语法","slug":"_1、lambda-语法","link":"#_1、lambda-语法","children":[]},{"level":3,"title":"2、Functional Interface（函数式接口）","slug":"_2、functional-interface-函数式接口","link":"#_2、functional-interface-函数式接口","children":[]},{"level":3,"title":"3、方法引用（Method Reference）","slug":"_3、方法引用-method-reference","link":"#_3、方法引用-method-reference","children":[]},{"level":3,"title":"4、Stream API 基础","slug":"_4、stream-api-基础","link":"#_4、stream-api-基础","children":[]}]},{"level":2,"title":"Java 输入/输出（I/O 流）","slug":"java-输入-输出-i-o-流","link":"#java-输入-输出-i-o-流","children":[{"level":3,"title":"1、字节流（InputStream, OutputStream）","slug":"_1、字节流-inputstream-outputstream","link":"#_1、字节流-inputstream-outputstream","children":[]},{"level":3,"title":"2、字符流（Reader, Writer）","slug":"_2、字符流-reader-writer","link":"#_2、字符流-reader-writer","children":[]},{"level":3,"title":"3、文件操作（File 类）","slug":"_3、文件操作-file-类","link":"#_3、文件操作-file-类","children":[]},{"level":3,"title":"4、序列化与反序列化","slug":"_4、序列化与反序列化","link":"#_4、序列化与反序列化","children":[]}]},{"level":2,"title":"并发基础","slug":"并发基础","link":"#并发基础","children":[{"level":3,"title":"1、线程的创建（Thread vs Runnable）","slug":"_1、线程的创建-thread-vs-runnable","link":"#_1、线程的创建-thread-vs-runnable","children":[]},{"level":3,"title":"2、synchronized 关键字（方法同步、代码块同步）","slug":"_2、synchronized-关键字-方法同步、代码块同步","link":"#_2、synchronized-关键字-方法同步、代码块同步","children":[]},{"level":3,"title":"3、volatile 关键字","slug":"_3、volatile-关键字","link":"#_3、volatile-关键字","children":[]},{"level":3,"title":"4、wait() / notify() / notifyAll()","slug":"_4、wait-notify-notifyall","link":"#_4、wait-notify-notifyall","children":[]},{"level":3,"title":"5、线程池基础（Executors 工具类）","slug":"_5、线程池基础-executors-工具类","link":"#_5、线程池基础-executors-工具类","children":[]},{"level":3,"title":"6、ThreadLocal","slug":"_6、threadlocal","link":"#_6、threadlocal","children":[]}]}],"git":{"updatedTime":1739025779000,"contributors":[{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":4,"url":"https://github.com/Clarence"},{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":6,"url":"https://github.com/hanchen"}]},"filePathRelative":"java/1_base.md"}');export{v as comp,f as data};
