import{_ as s,c as o,b as e,d as l,e as r,f as t,a as i,r as d,o as h}from"./app-DonQmjTH.js";const c={};function p(u,a){const n=d("RouteLink");return h(),o("div",null,[a[10]||(a[10]=e("h1",{id:"java-高级",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#java-高级"},[e("span",null,"Java 高级")])],-1)),a[11]||(a[11]=e("h2",{id:"一、泛型-generics",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#一、泛型-generics"},[e("span",null,"一、泛型（Generics）")])],-1)),e("p",null,[a[1]||(a[1]=l("详情见：")),r(n,{to:"/interview/0_java#十四、说说你对泛型的理解"},{default:t(()=>a[0]||(a[0]=[l("Java总结-Java：十四、说说你对泛型的理解")])),_:1})]),a[12]||(a[12]=e("h2",{id:"二、lambda表达式与函数式编程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#二、lambda表达式与函数式编程"},[e("span",null,"二、Lambda表达式与函数式编程")])],-1)),a[13]||(a[13]=e("h3",{id:"_1、lambda-底层原理与-函数式接口",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1、lambda-底层原理与-函数式接口"},[e("span",null,"1、Lambda 底层原理与 函数式接口")])],-1)),e("p",null,[a[3]||(a[3]=l("详情见：")),r(n,{to:"/interview/0_java#十五、说说-lambda-表达式的底层原理"},{default:t(()=>a[2]||(a[2]=[l(" Java总结-Java：十五、说说lambda表达式的底层原理")])),_:1})]),a[14]||(a[14]=e("h3",{id:"_2、流式api-stream-api-与集合框架的结合",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2、流式api-stream-api-与集合框架的结合"},[e("span",null,"2、流式API（Stream API）与集合框架的结合")])],-1)),a[15]||(a[15]=e("p",null,[l("Java 8引入的Stream API提供了一种以声明式方式处理集合的能力。Stream API提供了丰富的操作链式调用，如"),e("strong",null,"map、filter、reduce"),l(" 等，能够使得代码更加简洁和具备函数式编程风格。")],-1)),e("ul",null,[e("li",null,[e("p",null,[a[5]||(a[5]=e("strong",null,"流的种类",-1)),a[6]||(a[6]=l("：详情见：")),r(n,{to:"/interview/0_java#十六、说说java的stream"},{default:t(()=>a[4]||(a[4]=[l("Java总结-Java：说说Java的stream")])),_:1})])]),a[7]||(a[7]=i("<li><p><strong>集合框架与流结合</strong>：</p><ul><li><strong><code>Collection.stream()</code></strong>：从集合（如<code>List</code>、<code>Set</code>）中创建流。</li><li><strong><code>Stream.collect()</code></strong>：用于将流的结果收集到集合中，支持自定义收集器。</li><li><strong><code>Stream.forEach()</code></strong>：对流中的每个元素执行操作。</li></ul></li>",1))]),a[16]||(a[16]=i('<h2 id="三、多线程与并发编程" tabindex="-1"><a class="header-anchor" href="#三、多线程与并发编程"><span>三、多线程与并发编程</span></a></h2><h3 id="_1、aps原理-多线程基础" tabindex="-1"><a class="header-anchor" href="#_1、aps原理-多线程基础"><span>1、Aps原理-多线程基础</span></a></h3><p><a href="https://mp.weixin.qq.com/s/kvmX6-Iz38mG5907itEb2w" target="_blank" rel="noopener noreferrer">30张图彻底掌握Aqs-苏三说技术</a></p><h3 id="_2、线程池与executor框架" tabindex="-1"><a class="header-anchor" href="#_2、线程池与executor框架"><span>2、线程池与Executor框架</span></a></h3><h3 id="_3、synchronized与锁机制" tabindex="-1"><a class="header-anchor" href="#_3、synchronized与锁机制"><span>3、<code>synchronized</code>与锁机制</span></a></h3>',5)),e("p",null,[a[9]||(a[9]=l("详情见: ")),r(n,{to:"/concurrent/0_concurrent#二、juc-lock"},{default:t(()=>a[8]||(a[8]=[l("Java并发：二、juc-lock")])),_:1})]),a[17]||(a[17]=i('<h3 id="_4、volatile-final与并发中的内存可见性问题" tabindex="-1"><a class="header-anchor" href="#_4、volatile-final与并发中的内存可见性问题"><span>4、<code>volatile</code>, <code>final</code>与并发中的内存可见性问题</span></a></h3><h3 id="_5、completablefuture与异步编程" tabindex="-1"><a class="header-anchor" href="#_5、completablefuture与异步编程"><span>5、<code>CompletableFuture</code>与异步编程</span></a></h3><h2 id="四、反射机制-reflection" tabindex="-1"><a class="header-anchor" href="#四、反射机制-reflection"><span>四、反射机制（Reflection）</span></a></h2><h3 id="_1、反射的基本概念与使用" tabindex="-1"><a class="header-anchor" href="#_1、反射的基本概念与使用"><span>1、反射的基本概念与使用</span></a></h3><h3 id="_2、反射的应用场景" tabindex="-1"><a class="header-anchor" href="#_2、反射的应用场景"><span>2、反射的应用场景</span></a></h3><h3 id="_4、性能影响与优化" tabindex="-1"><a class="header-anchor" href="#_4、性能影响与优化"><span>4、性能影响与优化</span></a></h3><h2 id="五、注解与元编程" tabindex="-1"><a class="header-anchor" href="#五、注解与元编程"><span>五、注解与元编程</span></a></h2><h3 id="_1、注解的定义与使用" tabindex="-1"><a class="header-anchor" href="#_1、注解的定义与使用"><span>1、注解的定义与使用</span></a></h3><h3 id="_2、自定义注解与反射结合" tabindex="-1"><a class="header-anchor" href="#_2、自定义注解与反射结合"><span>2、自定义注解与反射结合</span></a></h3><h3 id="_3、注解处理器-annotation-processor" tabindex="-1"><a class="header-anchor" href="#_3、注解处理器-annotation-processor"><span>3、注解处理器（Annotation Processor）</span></a></h3><h2 id="六、模块化与java-9的新特性" tabindex="-1"><a class="header-anchor" href="#六、模块化与java-9的新特性"><span>六、模块化与Java 9的新特性</span></a></h2><h3 id="_1、java-9引入的模块系统-project-jigsaw" tabindex="-1"><a class="header-anchor" href="#_1、java-9引入的模块系统-project-jigsaw"><span>1、Java 9引入的模块系统（Project Jigsaw）</span></a></h3><h3 id="_2、模块化的优势与挑战" tabindex="-1"><a class="header-anchor" href="#_2、模块化的优势与挑战"><span>2、模块化的优势与挑战</span></a></h3><h2 id="七、高级特性总结" tabindex="-1"><a class="header-anchor" href="#七、高级特性总结"><span>七、高级特性总结</span></a></h2><h3 id="_1、高级特性的应用场景回顾" tabindex="-1"><a class="header-anchor" href="#_1、高级特性的应用场景回顾"><span>1、高级特性的应用场景回顾</span></a></h3><p>（如Project Loom, Project Panama等）</p><h3 id="_2、未来发展与趋势" tabindex="-1"><a class="header-anchor" href="#_2、未来发展与趋势"><span>2、未来发展与趋势</span></a></h3>',17))])}const m=s(c,[["render",p],["__file","2_advanced.html.vue"]]),_=JSON.parse('{"path":"/java/2_advanced.html","title":"Java 高级","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、泛型（Generics）","slug":"一、泛型-generics","link":"#一、泛型-generics","children":[]},{"level":2,"title":"二、Lambda表达式与函数式编程","slug":"二、lambda表达式与函数式编程","link":"#二、lambda表达式与函数式编程","children":[{"level":3,"title":"1、Lambda 底层原理与 函数式接口","slug":"_1、lambda-底层原理与-函数式接口","link":"#_1、lambda-底层原理与-函数式接口","children":[]},{"level":3,"title":"2、流式API（Stream API）与集合框架的结合","slug":"_2、流式api-stream-api-与集合框架的结合","link":"#_2、流式api-stream-api-与集合框架的结合","children":[]}]},{"level":2,"title":"三、多线程与并发编程","slug":"三、多线程与并发编程","link":"#三、多线程与并发编程","children":[{"level":3,"title":"1、Aps原理-多线程基础","slug":"_1、aps原理-多线程基础","link":"#_1、aps原理-多线程基础","children":[]},{"level":3,"title":"2、线程池与Executor框架","slug":"_2、线程池与executor框架","link":"#_2、线程池与executor框架","children":[]},{"level":3,"title":"3、synchronized与锁机制","slug":"_3、synchronized与锁机制","link":"#_3、synchronized与锁机制","children":[]},{"level":3,"title":"4、volatile, final与并发中的内存可见性问题","slug":"_4、volatile-final与并发中的内存可见性问题","link":"#_4、volatile-final与并发中的内存可见性问题","children":[]},{"level":3,"title":"5、CompletableFuture与异步编程","slug":"_5、completablefuture与异步编程","link":"#_5、completablefuture与异步编程","children":[]}]},{"level":2,"title":"四、反射机制（Reflection）","slug":"四、反射机制-reflection","link":"#四、反射机制-reflection","children":[{"level":3,"title":"1、反射的基本概念与使用","slug":"_1、反射的基本概念与使用","link":"#_1、反射的基本概念与使用","children":[]},{"level":3,"title":"2、反射的应用场景","slug":"_2、反射的应用场景","link":"#_2、反射的应用场景","children":[]},{"level":3,"title":"4、性能影响与优化","slug":"_4、性能影响与优化","link":"#_4、性能影响与优化","children":[]}]},{"level":2,"title":"五、注解与元编程","slug":"五、注解与元编程","link":"#五、注解与元编程","children":[{"level":3,"title":"1、注解的定义与使用","slug":"_1、注解的定义与使用","link":"#_1、注解的定义与使用","children":[]},{"level":3,"title":"2、自定义注解与反射结合","slug":"_2、自定义注解与反射结合","link":"#_2、自定义注解与反射结合","children":[]},{"level":3,"title":"3、注解处理器（Annotation Processor）","slug":"_3、注解处理器-annotation-processor","link":"#_3、注解处理器-annotation-processor","children":[]}]},{"level":2,"title":"六、模块化与Java 9的新特性","slug":"六、模块化与java-9的新特性","link":"#六、模块化与java-9的新特性","children":[{"level":3,"title":"1、Java 9引入的模块系统（Project Jigsaw）","slug":"_1、java-9引入的模块系统-project-jigsaw","link":"#_1、java-9引入的模块系统-project-jigsaw","children":[]},{"level":3,"title":"2、模块化的优势与挑战","slug":"_2、模块化的优势与挑战","link":"#_2、模块化的优势与挑战","children":[]}]},{"level":2,"title":"七、高级特性总结","slug":"七、高级特性总结","link":"#七、高级特性总结","children":[{"level":3,"title":"1、高级特性的应用场景回顾","slug":"_1、高级特性的应用场景回顾","link":"#_1、高级特性的应用场景回顾","children":[]},{"level":3,"title":"2、未来发展与趋势","slug":"_2、未来发展与趋势","link":"#_2、未来发展与趋势","children":[]}]}],"git":{"updatedTime":1745640513000,"contributors":[{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":13,"url":"https://github.com/Clarence"},{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":6,"url":"https://github.com/hanchen"}]},"filePathRelative":"java/2_advanced.md"}');export{m as comp,_ as data};
