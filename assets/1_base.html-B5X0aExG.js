import{_ as e,c as h,a as l,o as s}from"./app-CRNwiZHM.js";const n={};function r(t,a){return s(),h("div",null,a[0]||(a[0]=[l('<h1 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础"><span>Java基础</span></a></h1><h2 id="一、hashmap基本原理" tabindex="-1"><a class="header-anchor" href="#一、hashmap基本原理"><span>一、Hashmap基本原理</span></a></h2><p>HashMap 是一种基于哈希表的数据结构，它实现了 Map 接口，用于存储键值对 (key-value)。其基本原理如下：</p><h3 id="_1-哈希表-hash-table" tabindex="-1"><a class="header-anchor" href="#_1-哈希表-hash-table"><span>1. 哈希表（Hash Table）</span></a></h3><p>HashMap 是基于哈希表实现的，哈希表的基本思想是通过将数据的键值对映射到一个数组的索引位置上来提高数据查找的效率。具体流程如下：</p><ul><li><p>哈希函数： HashMap 使用哈希函数将键（key）映射到数组的索引位置。哈希函数的目的是通过计算一个值，将不同的键映射到哈希表中的位置。</p></li><li><p>数组： 哈希表内部使用一个数组来存储数据。数组中的每个元素存储一个链表（或者在 Java 8 后是红黑树），用于处理哈希冲突。</p></li></ul><h3 id="_2-哈希冲突" tabindex="-1"><a class="header-anchor" href="#_2-哈希冲突"><span>2. 哈希冲突</span></a></h3><p>由于哈希函数不可能做到完全唯一的映射，不同的键可能会被映射到相同的索引，这种情况称为哈希冲突。HashMap 通过以下方式解决哈希冲突：</p><ul><li><p>链表法（链式哈希）： 在发生冲突的情况下，HashMap 会将冲突的键值对存储到一个链表中（或者红黑树）。当多个元素映射到同一个索引位置时，它们会形成一个链表。</p></li><li><p>红黑树法：在 Java 8 及以后的版本中，如果链表的长度超过一定阈值（默认为 8），HashMap 会将链表转化为红黑树，以提高查询效率。</p></li></ul><h3 id="_3-扩容机制" tabindex="-1"><a class="header-anchor" href="#_3-扩容机制"><span>3. 扩容机制</span></a></h3><p>当 HashMap 中的元素过多时，哈希表的负载因子（load factor）可能会达到阈值，导致哈希表的存储效率降低。默认情况下，负载因子为 0.75。<strong>当元素个数超过当前容量 * 负载因子时，HashMap 会进行扩容</strong>（通常是原数组大小的 2 倍）。</p><p>扩容过程中，所有元素的哈希值会被重新计算，并重新放置到新的数组位置。这是因为<strong>哈希表的大小发生变化，导致原先的索引位置不再适用</strong>。</p><h3 id="_4-时间复杂度" tabindex="-1"><a class="header-anchor" href="#_4-时间复杂度"><span>4. 时间复杂度</span></a></h3><ul><li>查找、插入、删除操作的时间复杂度：</li></ul><p>在理想情况下，哈希表的查找、插入和删除操作的时间复杂度为 O(1)。但是，如果发生哈希冲突，性能会退化到 O(n)（链表长度为 n 时）。使用红黑树优化后，最坏情况下时间复杂度为 O(log n)。</p><ul><li>扩容操作的时间复杂度：</li></ul><p>扩容是一个相对耗时的操作，时间复杂度为 O(n)，但扩容操作是按需进行的，不是频繁发生，因此平均而言，HashMap 的操作仍然是 O(1)。</p><h3 id="_5-关键特点" tabindex="-1"><a class="header-anchor" href="#_5-关键特点"><span>5. 关键特点</span></a></h3><ul><li>非线程安全：HashMap 不是线程安全的，如果在多线程环境下使用，需要考虑同步问题。</li><li>允许 null 键和 null 值：HashMap 允许一个 null 键和多个 null 值。</li><li>元素顺序不保证：HashMap 不保证键值对的顺序，因为它是基于哈希函数计算索引的，顺序是无序的。如果需要顺序，可以使用 LinkedHashMap</li></ul><h2 id="二、treemap基本原理" tabindex="-1"><a class="header-anchor" href="#二、treemap基本原理"><span>二、TreeMap基本原理</span></a></h2><h2 id="hashmap和hashtable的区别" tabindex="-1"><a class="header-anchor" href="#hashmap和hashtable的区别"><span>HashMap和HashTable的区别</span></a></h2><h2 id="hashmap和concurrenthashmap的区别" tabindex="-1"><a class="header-anchor" href="#hashmap和concurrenthashmap的区别"><span>HashMap和ConcurrentHashMap的区别</span></a></h2><h3 id="_1、两者区别" tabindex="-1"><a class="header-anchor" href="#_1、两者区别"><span>1、两者区别</span></a></h3><h3 id="_2、currenthashmap为何放弃分段锁" tabindex="-1"><a class="header-anchor" href="#_2、currenthashmap为何放弃分段锁"><span>2、CurrentHashMap为何放弃分段锁？</span></a></h3><h2 id="threadlocal" tabindex="-1"><a class="header-anchor" href="#threadlocal"><span>ThreadLocal</span></a></h2><h3 id="_1、原理及其应用" tabindex="-1"><a class="header-anchor" href="#_1、原理及其应用"><span>1、原理及其应用</span></a></h3><h3 id="_2、transmittable-threadlocal" tabindex="-1"><a class="header-anchor" href="#_2、transmittable-threadlocal"><span>2、Transmittable ThreadLocal</span></a></h3>',27)]))}const p=e(n,[["render",r],["__file","1_base.html.vue"]]),c=JSON.parse('{"path":"/java/1_base.html","title":"Java基础","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、Hashmap基本原理","slug":"一、hashmap基本原理","link":"#一、hashmap基本原理","children":[{"level":3,"title":"1. 哈希表（Hash Table）","slug":"_1-哈希表-hash-table","link":"#_1-哈希表-hash-table","children":[]},{"level":3,"title":"2. 哈希冲突","slug":"_2-哈希冲突","link":"#_2-哈希冲突","children":[]},{"level":3,"title":"3. 扩容机制","slug":"_3-扩容机制","link":"#_3-扩容机制","children":[]},{"level":3,"title":"4. 时间复杂度","slug":"_4-时间复杂度","link":"#_4-时间复杂度","children":[]},{"level":3,"title":"5. 关键特点","slug":"_5-关键特点","link":"#_5-关键特点","children":[]}]},{"level":2,"title":"二、TreeMap基本原理","slug":"二、treemap基本原理","link":"#二、treemap基本原理","children":[]},{"level":2,"title":"HashMap和HashTable的区别","slug":"hashmap和hashtable的区别","link":"#hashmap和hashtable的区别","children":[]},{"level":2,"title":"HashMap和ConcurrentHashMap的区别","slug":"hashmap和concurrenthashmap的区别","link":"#hashmap和concurrenthashmap的区别","children":[{"level":3,"title":"1、两者区别","slug":"_1、两者区别","link":"#_1、两者区别","children":[]},{"level":3,"title":"2、CurrentHashMap为何放弃分段锁？","slug":"_2、currenthashmap为何放弃分段锁","link":"#_2、currenthashmap为何放弃分段锁","children":[]}]},{"level":2,"title":"ThreadLocal","slug":"threadlocal","link":"#threadlocal","children":[{"level":3,"title":"1、原理及其应用","slug":"_1、原理及其应用","link":"#_1、原理及其应用","children":[]},{"level":3,"title":"2、Transmittable ThreadLocal","slug":"_2、transmittable-threadlocal","link":"#_2、transmittable-threadlocal","children":[]}]}],"git":{"updatedTime":1738683248000,"contributors":[{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":3,"url":"https://github.com/Clarence"},{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":1,"url":"https://github.com/hanchen"}]},"filePathRelative":"java/1_base.md"}');export{p as comp,c as data};
