# Java总结-缓存
## 一、缓存数据不一致性问题
**【场景一】** 先操作缓存，再写数据库成功之前，如果有读请求发生，可能导致旧数据入缓存，引发数据不一致。在分布式环境下，数据的读
写都是并发的，一个服务多机器部署，对同一个数据进行读写，在数据库层面并不能保证完成顺序，就有可能后读的操作先完成
（读取到的是脏数据），如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。

**【解决办法】**：<br>
①、可采用更新前后双删除缓存策略；<br>
②、可以通过“串行化”解决，保证同一个数据的读写落在同一个后端服务上；

**【场景二】** 先操作数据库，再清除缓存。如果删缓存失败了，就会出现数据不一致问题。

**【方案一】** ：将删除失败的 key 值存入队列中重复删除，如下图：

![img.png](../assets/interview/cache-diff-one.png)

（1）更新数据库数据。

（2）缓存因为种种问题删除失败。

（3）将需要删除的key发送至消息队列。

（4）自己消费消息，获得需要删除的key。

（5）继续重试删除操作，直到成功。

> 【缺点】：对业务线代码造成大量的侵入。于是有了方案二。

**【方案二】**：通过订阅 binlog 获取需要重新删除的 Key 值数据。在应用程序中，另起一段程序，获得这个订阅程序传来的消息，进行删除缓存操作。
![img.png](/assets/interview/cache-diff-two.png)

（1）更新数据库数据

（2）数据库会将操作信息写入binlog日志当中

（3）订阅程序提取出所需要的数据以及key

（4）另起一段非业务代码，获得该信息

（5）尝试删除缓存操作，发现删除失败

（6）将这些信息发送至消息队列

（7）重新从消息队列中获得该数据，重试操作

## 二、Redis内存用完会发生什么

如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还是可以正常返回），或者将 Redis 当缓存使用，配置缓存淘汰机制，
当 Redis 达到内存的上线时会冲掉旧的数据。也会将value的数据通过 swap机制同步到磁盘进行存储。但是 key的之不能使用 swap机制。
如果key也很多的话，可以通过压缩记性存储。
